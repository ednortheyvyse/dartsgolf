<!DOCTYPE html>
<html lang="en">
<head>
  <!-- =========================================================
       PAGE META / PWA BASICS
       ========================================================= -->
  <meta charset="UTF-8">
  <!-- Prevent auto zoom on mobile + enable iOS safe areas -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Darts Golf Scorer</title>

  <!-- Manifest + theme-color for PWA -->
  <link rel="manifest" href="{{ url_for('static', filename='manifest.webmanifest') }}">
  <meta name="theme-color" content="#182634">

  <!-- iOS/Android standalone capability -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Darts Golf">
  <meta name="mobile-web-app-capable" content="yes">


  <!-- Service Worker registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => navigator.serviceWorker.register('/sw.js').catch(()=>{}));
    }
  </script>

  <!-- Favicons / Touch icons -->
  <link rel="icon" href="{{ url_for('static', filename='icons/dartboard.svg') }}" type="image/svg+xml">
  <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='icons/dartboard-32.png') }}">
  <link rel="icon" type="image/png" sizes="192x192" href="{{ url_for('static', filename='icons/dartboard-192.png') }}">
  <link rel="apple-touch-icon" sizes="180x180" href="{{ url_for('static', filename='icons/dartboard-180.png') }}">
  <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">

  <!-- Google Font for the main title -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Rye&family=Galada&display=swap" rel="stylesheet">

  <!-- =========================================================
       GLOBAL STYLES (CSS) - Externalized
       ========================================================= -->
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css', v=app_start_time) }}">
</head>

<body>
  <!-- =========================================================
       GLOBAL CANVAS FOR CONFETTI
       ========================================================= -->
  <canvas id="confettiCanvas"></canvas>

  <!-- =========================================================
       INITIAL LOADING OVERLAY
       ========================================================= -->
  <div id="initialLoadingOverlay" class="initial-loading-overlay">
    <div class="spinner"></div>
  </div>


  <!-- =========================================================
       MAIN CONTENT CONTAINER
       ========================================================= -->
  <div class="container">
    <!-- Flash message container (moved to global scope) -->
    <div class="flash-container">
      {% with messages = get_flashed_messages(with_categories=true) %}{% if messages %}{% for category, msg in messages %}
            <div class="flash {{ category or 'info' }}" role="alert">{{ msg }}</div>
          {% endfor %}
        {% endif %}
      {% endwith %}
    </div>
    {% if False %} {# This block is now unused, replaced by the player stats modal #}
      <!-- =====================================================
           PLAYER STATS VIEW
           ===================================================== -->
      <h1>{{ player_name }}</h1>
      <small class="stat-description" style="text-align: center; margin-top: -10px; margin-bottom: 20px;">Lifetime Stats</small>

      <div class="player-stats-grid">
        <div class="stat-block">
          <div class="stat-title">Games Played</div>
          <div class="stat-value">{{ player_stats.games_played or 0 }}</div>
        </div>
        <div class="stat-block">
          <div class="stat-title">Wins</div>
          <div class="stat-value">{{ player_stats.wins or 0 }}</div>
        </div>
        <div class="stat-block">
          <div class="stat-title">Win Rate</div>
          <div class="stat-value">{{ "%.1f"|format(player_stats.win_percentage) }}%</div>
        </div>
        <div class="stat-block">
          <div class="stat-title">Total Birdies</div>
          <div class="stat-value">{{ player_stats.total_birdies or 0 }}</div>
        </div>
        <div class="stat-block">
          <div class="stat-title">Total Bogeys</div>
          <div class="stat-value">{{ player_stats.total_bogeys or 0 }}</div>
        </div>
      </div>

    {% elif show_leaderboard %}
      <!-- =====================================================
           LEADERBOARD VIEW
           ===================================================== -->
      <h1 class="main-title" style="margin-bottom: 20px;">LEADERBOARD</h1>
      
      <div class="stat-block">
        <input type="search" id="leaderboardSearch" placeholder="Find a player..." class="settings-input" style="width: 100%; margin-bottom: 12px; padding: 12px; box-sizing: border-box; background: #101010; border: 1px solid var(--border-color); border-radius: 8px; color: #fff;">
        {% if leaderboard %}
          <ol id="leaderboardList">
            {% for player in leaderboard %}
              <li data-leaderboard-name="{{ player.name | lower }}" style="align-items: center;">
                <button type="button" class="btn btn-cancel" aria-label="Delete stats for {{ player.name }}" title="Delete player stats"
                        style="background-color: #582828; border: 1px solid #8c4343; flex-shrink: 0; padding: 0; font-size: 1em; line-height: 1; width: 27px; height: 27px; margin-right: 10px;"
                        onclick="deletePlayerStats('{{ player.name }}', this)">‚úï
                </button>
                <div class="stat-left" style="min-width: 0;" data-player-name="{{ player.name }}">
                  <a href="#" onclick="event.preventDefault();" class="stat-player-link">
                    <span class="stat-player">{{ player.name }}</span>
                  </a>
                </div>
                <div class="stat-right">
                  <span>{{ player.games_played }} Games</span>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="empty-list-text" style="padding: 20px 0;">No player stats found. Play a game to get on the board!</div>
        {% endif %}
      </div>
    {% elif show_stats %}
      <!-- =====================================================
           STATS VIEW
           ===================================================== -->
      <h1>GAME STATS</h1>


      <div class="stat-block">
        <div class="stat-title">‚õ≥ Birdie Streaks</div>
        <small class="stat-description">Longest consecutive run of rounds with a score below par.</small>
        {% if birdie_streak_ranking %}
          <ol>
            {% for row in birdie_streak_ranking %}
              <li>
                <div class="stat-left">
                  <a href="#" onclick="event.preventDefault(); openPlayerStats('{{ row.name }}', true)" class="stat-player-link" data-player-name="{{ row.name }}">
                    <span class="stat-player">{{ row.name }}</span>
                  </a>
                </div>
                <div class="stat-right">
                  <span>{{ row.streak }}</span>
                  <div class="stat-bar" data-width="{{ ((row.streak / (max_birdie_streak or 1) * 60) | round(0)) or (2 if row.streak > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>

      <div class="stat-block">
        <div class="stat-title">üî• Bogey Streaks</div>
        <small class="stat-description">Longest consecutive run of rounds with a score above par.</small>
        {% if bogey_streak_ranking %}
          <ol>
            {% for row in bogey_streak_ranking %}
              <li>
                <div class="stat-left">
                  <a href="#" onclick="event.preventDefault(); openPlayerStats('{{ row.name }}', true)" class="stat-player-link" data-player-name="{{ row.name }}">
                    <span class="stat-player">{{ row.name }}</span>
                  </a>
                </div>
                <div class="stat-right">
                  <span>{{ row.streak }}</span>
                  <div class="stat-bar bad" data-width="{{ ((row.streak / (max_bogey_streak or 1) * 60) | round(0)) or (2 if row.streak > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>

      <div class="stat-block">
        <div class="stat-title">üïäÔ∏è Total Birdies</div>
        <small class="stat-description">Total number of rounds with a score below par.</small>
        {% if most_birdies_ranking %}
          <ol>
            {% for row in most_birdies_ranking %}
              <li>
                <div class="stat-left">
                  <a href="#" onclick="event.preventDefault(); openPlayerStats('{{ row.name }}', true)" class="stat-player-link" data-player-name="{{ row.name }}">
                    <span class="stat-player">{{ row.name }}</span>
                  </a>
                </div>
                <div class="stat-right">
                  <span>{{ row.count }}</span>
                  <div class="stat-bar" data-width="{{ ((row.count / (max_birdie_count or 1) * 60) | round(0)) or (2 if row.count > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>
  
      <div class="stat-block">
        <div class="stat-title">üíî Total Bogeys</div>
        <small class="stat-description">Total number of rounds with a score above par.</small>
        {% if most_bogeys_ranking %}
          <ol>
            {% for row in most_bogeys_ranking %}
              <li>
                <div class="stat-left">
                  <a href="#" onclick="event.preventDefault(); openPlayerStats('{{ row.name }}', true)" class="stat-player-link" data-player-name="{{ row.name }}">
                    <span class="stat-player">{{ row.name }}</span>
                  </a>
                </div>
                <div class="stat-right">
                  <span>{{ row.count }}</span>
                  <div class="stat-bar bad" data-width="{{ ((row.count / (max_bogey_count or 1) * 60) | round(0)) or (2 if row.count > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>      

      <div class="stat-block">
        <div class="stat-title">üéØ On Target %</div>
        <small class="stat-description">Percentage of rounds completed at par or better.</small>
        {% if on_target_ranking %}
          <ol>
            {% for row in on_target_ranking %}
              <li>
                <div class="stat-left">
                  <a href="#" onclick="event.preventDefault(); openPlayerStats('{{ row.name }}', true)" class="stat-player-link" data-player-name="{{ row.name }}">
                    <span class="stat-player">{{ row.name }}</span>
                  </a>
                </div>
                <div class="stat-right">
                  <span>{{ row.percentage | round | int }}%</span>
                  <div class="stat-bar" data-width="{{ ((row.percentage / (max_on_target_percentage or 1) * 60) | round(0)) or (2 if row.percentage > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>


      
      <div class="stat-block"> {# Fixed stray char #}
        <div class="stat-title">üìä Average Scores</div>
        <small class="stat-description">Average score per round over the entire game.</small>
        {% if average_ranking %}
          <ol>
            {% for row in average_ranking %}
              <li>
                <div class="stat-left">
                  <a href="#" onclick="event.preventDefault(); openPlayerStats('{{ row.name }}', true)" class="stat-player-link" data-player-name="{{ row.name }}">
                    <span class="stat-player">{{ row.name }}</span>
                  </a>
                  <small class="stat-sub">(over {{ row.rounds }} rounds)</small>
                </div>
                <div class="stat-right">
                  <span>{{ "%+.2f"|format(row.average) }}</span>
                  <div class="stat-bar {{ 'bad' if row.average > 0 else ('neutral' if row.average == 0 else '') }}" data-width="{{ ((row.average|abs / (max_average_abs or 1) * 60) | round(0)) or (2 if row.average|abs > 0 else 0) }}px">
                  </div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>

      <div class="stat-block">
        <div class="stat-title">üìà Biggest Saves</div>
        <small class="stat-description">Largest score improvement in the game.</small>
        {% if comeback_ranking %}
          <ol>
            {% for cb in comeback_ranking %}
              <li>
                <div class="stat-left">
                  <a href="#" onclick="event.preventDefault(); openPlayerStats('{{ cb.player }}', true)" class="stat-player-link" data-player-name="{{ cb.player }}">
                    <span class="stat-player">{{ cb.player }}</span>
                  </a>
                  <small class="stat-sub">
                    from {{ "%+d"|format(cb.from_score) }} on Round {{ cb.from_round }}
                    to {{ "%+d"|format(cb.to_score) }} on Round {{ cb.to_round }}
                  </small>
                </div>
                <div class="stat-right">
                  <span>{{ cb.improvement }} saved</span>
                  <div class="stat-bar" data-width="{{ ((cb.improvement / (max_comeback_improvement or 1) * 60) | round(0)) or (2 if cb.improvement > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No positive improvements detected.</small>
        {% endif %}
      </div>

      <div class="stat-block">
        <div class="stat-title">üìâ Worst Falls</div>
        <small class="stat-description">Largest score drop in the game.</small>
        {% if fall_ranking %}
          <ol>
            {% for fall in fall_ranking %}
              <li>
                <div class="stat-left">
                  <a href="#" onclick="event.preventDefault(); openPlayerStats('{{ fall.player }}', true)" class="stat-player-link" data-player-name="{{ fall.player }}">
                    <span class="stat-player">{{ fall.player }}</span>
                  </a>
                  <small class="stat-sub">
                    from {{ "%+d"|format(fall.from_score) }} on Round {{ fall.from_round }}
                    to {{ "%+d"|format(fall.to_score) }} on Round {{ fall.to_round }}
                  </small>
                </div>
                <div class="stat-right">
                  <span>{{ fall.worsening }} lost</span>
                  <div class="stat-bar bad" data-width="{{ ((fall.worsening / (max_fall_worsening or 1) * 60) | round(0)) or (2 if fall.worsening > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No score worsening detected.</small>
        {% endif %}
      </div>

    {% else %}
      <!-- =====================================================
           NORMAL GAME VIEWS
           ===================================================== -->

      {% if game.phase == 'setup' %}
        <!-- =========================
             SETUP PHASE
             ========================= -->
        <div class="setup-screen">
          <h1 class="main-title">
            <span class="title-main">DARTS GOLF</span>
            <span class="title-sub">Scorer</span>
          </h1>

          <!-- Add-one-name-at-a-time input -->
            <div class="name-input-wrap" style="position:relative; display:flex; gap:8px; align-items:center; margin-top:8px;">
              <input
                id="nameField"
                type="text"
                placeholder="Type a player name"
                aria-label="Player name"
                class="settings-input"
                style="flex:1; padding-right:56px; padding-top: 12px; padding-bottom: 12px; box-sizing: border-box;"
                autocomplete="off"
                inputmode="text"
                maxlength="14"
              >
              <button
                type="button"
                id="addNameBtn"
                class="settings-btn"
                aria-label="Add player"
                title="Add player"
                style="position:absolute; right:6px; top:50%; transform:translateY(-50%); padding:8px 12px;"
              >‚ûú</button>
            </div>
          <form id="startForm" action="{{ url_for('start_game') }}" method="post" style="margin-top:12px;">
            <input id="playersInput" type="hidden" name="players" required>
            <small style="display:block; color:#bbb; margin-top:6px;">
              Press <b>Enter</b> or tap the arrow to add. Tap <b>‚úï</b> to remove. Drag pills to reorder.
            </small>

          </form>
          <!-- New two-column container for player lists -->
          <div class="player-lists-container">
            <!-- Left Column: Selected Players -->
            <div class="player-list-wrap" id="selectedWrap">
              <div class="player-list-title">Players (drag to reorder)</div>
              <div id="selectedChipList" class="chip-list"></div>
            </div>
            <!-- Right Column: Recent Players -->
            <div class="player-list-wrap" id="recentWrap">
              <div class="player-list-title">Recent players</div>
              <div id="chipList" class="chip-list"></div>
            </div>
          </div>

        </div>

      {% elif game.phase == 'playing' %}
        <!-- =========================
             PLAYING PHASE
             ========================= -->
        <div class="info-bar {{ 'ending' if game.end_after_round else '' }}" id="info-bar" aria-live="polite" role="status">
          <div class="round-count">
            <span class="round-label">ROUND</span>
            <span class="round-number-wrapper">
              <span class="round-number-digit old-digit" style="transform: translateY(0); opacity: 1;">{{ "%02d"|format(game.current_round) }}</span>
              <span class="round-number-digit new-digit" style="transform: translateY(100%); opacity: 0;"></span>
            </span>
            <span class="round-total">/ {{ game.holes }}</span>
          </div>
          <div class="turn-info">
            {% if game.end_after_round %}FINAL ROUND{% else %}{{ game.players[game.current_player_index] }}'s Turn{% endif %}
          </div>
        </div>

        <table class="scoreboard playing" id="scoreboard">
          <thead>
            <tr><th scope="col">&nbsp;</th>
              {% for p in game.players %}
                {% set is_cur = (p == game.players[game.current_player_index]) %}
                <th scope="col" class="{{ 'current-player-header' if is_cur else '' }}">
                  {% if game.players|length > 4 %}
                    {{ p.split(' ')|map('first')|join('')|upper }}
                  {% else %}
                    {{ p }}
                  {% endif %}
                </th>
              {% endfor %}
            </tr>
          </thead>
          <tbody>
            <tbody>
  <tr class="total-row"><th>Total</th>
    {% for p in game.players %}
      {% set s = game.scores.get(p, 0) %} {# This is a data cell, not a header #}
      <td>{% if s > 0 %}+{% endif %}{{ s }}</td>
    {% endfor %}
  </tr>

  <!-- ‚úÖ Current round being played -->
  <tr class="current-row"><th>{{ "%02d"|format(game.current_round) }}</th>
    {% for p in game.players %}
      {% set v = game.round_history[game.current_round - 1].get(p) %} {# This is a data cell, not a header #}
      {% set is_cur_cell = (loop.index0 == game.current_player_index) %}
      {% if v is not none %}
        {% set ns = namespace(total=0) %}
        {% for r in range(game.current_round) %}
          {% set ns.total = ns.total + (game.round_history[r].get(p, 0)) %}
        {% endfor %}
        <td>
          <div class="cell">
            <span class="total-pill">{{ ns.total > 0 and '+' or '' }}{{ ns.total }}</span>
            <span class="delta-corner {{ 'pos' if v > 0 else ('neg' if v < 0 else 'zero') }}">
              {{ v > 0 and '+' or '' }}{{ v }}
            </span>
          </div>
        </td>
      {% else %}
        <td class="{{ 'current-player-cell' if is_cur_cell else '' }}">
          <div class="cell">
            <span class="total-pill">0</span>
            <span class="delta-corner hidden">0</span>
          </div>
        </td>
      {% endif %}
    {% endfor %}
  </tr>

  <!-- üîÅ Previous rounds (from latest to earliest) -->
  {% for i in range(game.current_round - 1) | reverse %}
    <tr><th>{{ "%02d"|format(i + 1) }}</th>
      {% for p in game.players %} {# This is a data cell, not a header #}
        {% set v = game.round_history[i].get(p) %}
        {% if v is not none %}
          {% set ns = namespace(total=0) %}
          {% for r in range(i + 1) %}
            {% set ns.total = ns.total + (game.round_history[r].get(p, 0)) %}
          {% endfor %}
          <td>
            <div class="cell">
              <span class="total-pill">{{ ns.total > 0 and '+' or '' }}{{ ns.total }}</span>
              <span class="delta-corner {{ 'pos' if v > 0 else ('neg' if v < 0 else 'zero') }}">
                {{ v > 0 and '+' or '' }}{{ v }}
              </span>
            </div>
          </td>
        {% else %}
          <td></td>
        {% endif %}
      {% endfor %}
    </tr>
  {% endfor %}
</tbody>

        </table>

      {% elif game.phase == 'playoff' %}
        <!-- =========================
             PLAYOFF (TIE-BREAKER) PHASE
             ========================= -->
        <div class="info-bar" id="info-bar" aria-live="polite" role="status">
          <div class="round-count">
            <span class="round-label">TIE-BREAKER</span>
            <span class="round-number-digit old-digit" style="transform: translateY(0); opacity: 1;">{{ "%02d"|format(game.playoff_round) }}</span>
            <span class="round-number-digit new-digit" style="transform: translateY(100%); opacity: 0;"></span>
            </span>
          </div>
          <div class="turn-info">
            {% if game.playoff_group %}{{ game.playoff_group[game.current_player_index] }}'s Turn{% endif %}
          </div>
        </div>
                <table class="scoreboard" id="scoreboard">
          {# -----------------------------------------------------
             BUILD A STABLE COLUMN SET (ALL PLAYERS IN THIS TIE)
             ----------------------------------------------------- #}
          {% set tie_players = game.playoff_pool %}

          <thead>
            <tr><th scope="col">&nbsp;</th>
              {% for p in tie_players %}
                {# highlight only if this header is the current shooter #}
                {% set is_cur = (game.playoff_group and p == game.playoff_group[game.current_player_index]) %}
                <th scope="col" class="{{ 'current-player-header' if is_cur else '' }}" data-player-name="{{ p }}">
                  {% if tie_players|length > 4 %}
                    {{ p.split(' ')|map('first')|join('')|upper }}
                  {% else %}
                    {{ p }}
                  {% endif %}
                </th>
              {% endfor %}
            </tr>
          </thead>

          <tbody>
            <!-- Stable total row: base score repeated across all tie players -->
            <tr class="total-row">
              <th scope="row">Total</th>
              {% for _ in tie_players %}
                {% set s = game.playoff_base_score %}
                <td>{% if s > 0 %}+{% endif %}{{ s }}</td>
              {% endfor %}
            </tr>

            <!-- ‚úÖ Current TB round being played (use stable columns) -->
            <tr class="current-row">
              <th scope="row">TB {{ "%02d"|format(game.playoff_round) }}</th>
              {% for p in tie_players %}
                {% set v = game.playoff_round_scores.get(p) %}
                {% set is_current = (game.playoff_group and p == game.playoff_group[game.current_player_index]) %}
                {% if v is not none %}
                  <td>
                    <div class="cell">
                      <span class="total-pill">{{ v > 0 and '+' or '' }}{{ v }}</span>
                      <span class="delta-corner {{ 'pos' if v > 0 else ('neg' if v < 0 else 'zero') }}">
                        {{ v > 0 and '+' or '' }}{{ v }}
                      </span>
                    </div>
                  </td>
                {% else %}
                  <td class="{{ 'current-player-cell' if is_current else '' }}">
                    <div class="cell">
                      <span class="total-pill">0</span>
                      <span class="delta-corner hidden">0</span>
                    </div>
                  </td>
                {% endif %}
              {% endfor %}
            </tr>

  <!-- üîÅ Past completed TB rounds -->
  {% set total_tb = game.playoff_history|length %}
  {% for round_scores in game.playoff_history | reverse %}
    {% set tb_num = total_tb - loop.index0 %}
    <tr>
      <th scope="row">TB {{ "%02d"|format(tb_num) }}</th>
      {% for p in tie_players %} {# Use the stable tie_players list #}
        {% set v = round_scores.get(p) %}
        {% if v is not none %}
          <td>
            <div class="cell">
              <span class="total-pill">{{ v > 0 and '+' or '' }}{{ v }}</span>
              <span class="delta-corner {{ 'pos' if v > 0 else ('neg' if v < 0 else 'zero') }}">
                {{ v > 0 and '+' or '' }}{{ v }}
              </span>
            </div>
          </td>
        {% else %}
          <td></td>
        {% endif %}
      {% endfor %}
    </tr>
  {% endfor %}

          </tbody>
        </table>


      {% elif game.phase == 'final_ranking' %}
        <!-- =========================
             FINAL RANKING PHASE
             ========================= -->
        <div id="final-capture">
          <div class="status-box">
            <img src="{{ url_for('static', filename='images/finalstanding1.png') }}" alt="Final Standings" class="final-standings-img">
          </div>

          {% set winner_name = game.winner or (game.final_standings and game.final_standings[0].name) %}
          {% if winner_name %}
            <div class="winner-banner" role="status" aria-live="polite">
              üèÜ WINNER: {{ winner_name }}
            </div>
          {% endif %}

          <table class="scoreboard final" id="scoreboard">
            <thead> {# Add a caption for overall table context #}
              <tr><th scope="col">&nbsp;</th>
                {% for st in game.final_standings %}
                  <th scope="col">{% set r=st.rank %}{% set sfx='th' %}
                      {% if r % 10 == 1 and r % 100 != 11 %}{% set sfx='st' %}{% endif %}
                      {% if r % 10 == 2 and r % 100 != 12 %}{% set sfx='nd' %}{% endif %}
                      {% if r % 10 == 3 and r % 100 != 13 %}{% set sfx='rd' %}{% endif %}
                      {{ r }}{{ sfx }}</th>
                {% endfor %}
              </tr>
              <tr><th scope="col">Player</th>
                {% for st in game.final_standings %}
                  <th scope="col" class="final-player-header">
                    {{ 'üèÜ ' if st.rank == 1 else '' }}
                    {% if game.final_standings|length > 4 %}
                      {{ st.name.split(' ')|map('first')|join('')|upper }}
                    {% else %}
                      {{ st.name }}
                    {% endif %}
                  </th>
                {% endfor %}
              </tr>
            </thead>
            <tbody>
              <tr class="total-row"><th scope="row">Final</th>
                {% for st in game.final_standings %}
                  {% set s = st.score %}
                  <td>{% if s>0 %}+{% endif %}{{ s }}</td>
                {% endfor %}
              </tr>

              {% for i in range(game.max_playoff_rounds, 0, -1) %}
                <tr><th>TB {{ "%02d"|format(i) }}</th>
                  {% for st in game.final_standings %} {# This is a data cell, not a header #}
                    {% set hist = game.all_playoff_history.get(st.name, []) %}
                    {% if i <= hist|length %}
                      {% set v = hist[i-1] %}
                    <td>
                        <div class="cell">
                          <span class="total-pill">{{ v>0 and '+' or '' }}{{ v }}</span>
                          <span class="delta-corner {{ 'pos' if v > 0 else ('neg' if v < 0 else 'zero') }}">
                            {{ v>0 and '+' or '' }}{{ v }}
                          </span>
                        </div>
                      </td>
                    {% else %}
                      <td>-</td>
                    {% endif %}
                  {% endfor %}
                </tr>
              {% endfor %}

              {% set rp = game.rounds_played or 0 %}
              {% for i in range(rp - 1, -1, -1) %}
                <tr><th scope="row">{{ "%02d"|format(i + 1) }}</th>
                  {% for st in game.final_standings %}
                    {% set v = game.round_history[i].get(st.name) %}
                    {% if v is not none %}
                      {% set ns = namespace(total=0) %}
                      {% for r in range(i + 1) %}
                        {% set ns.total = ns.total + (game.round_history[r].get(st.name, 0)) %}
                      {% endfor %}
                      <td>
                        <div class="cell">
                          <span class="total-pill">{{ ns.total>0 and '+' or '' }}{{ ns.total }}</span>
                          <span class="delta-corner {{ 'pos' if v>0 else ('neg' if v<0 else 'zero') }}">
                            {{ v>0 and '+' or '' }}{{ v }}
                          </span>
                        </div>
                      </td>
                    {% else %}
                      <td></td>
                    {% endif %}
                  {% endfor %}
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      {% endif %}
    {% endif %}
  </div>

  <!-- =========================================================
       MODALS
       ========================================================= -->
  <div id="confirmOverlay" class="modal-overlay" aria-hidden="true" style="background: rgba(0,0,0,0.8);">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmMessage">
      <h3 id="confirmTitle">Confirm</h3>
      <p id="confirmMessage">Are you sure?</p>
      <div class="modal-actions">
        <button type="button" class="btn btn-cancel" id="confirmCancelBtn">Cancel</button>
        <button type="button" class="btn btn-confirm" id="confirmOkBtn">OK</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal (with Add to Home Screen button) -->
  <div id="settingsOverlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <div class="modal-header" style="display: flex; justify-content: space-between; align-items: center;">
        <h3 id="settingsTitle" style="margin: 0; flex-shrink: 0;">Settings</h3>
        <div style="text-align: right;">
          <div id="sidDisplay" class="sid-display"></div>
          <div id="uptimeDisplay" class="sid-display" style="margin-top: 4px;"></div>
        </div>
      </div>
      <div class="settings-grid">

        <!-- Rudeness Slider -->
        <div class="settings-group" id="rudenessSettingsRow">
          <label for="rudenessSlider" style="font-weight: 700; display: block;">
            Rudeness: <span id="rudenessLabel">Serious</span>
          </label>
          <div id="rudenessSlider" class="slider-container">
            <div class="slider-track"></div>
            <div class="slider-thumb"></div>
          </div>
          <div class="settings-help">
            Adjust the tone of the score announcements.
          </div>
        </div>
        
        <!-- Holes setting (only in setup) -->
        <div class="settings-group" id="holesSettingsRow" style="display: none;">
          <label for="holesInput" style="font-weight: 700; display: block;">Number of Rounds (Holes)</label>
          <input id="holesInput" type="number" class="settings-input" min="1" max="50" step="1" style="width: 100%; box-sizing: border-box; padding: 12px; background: #101010; border: 1px solid var(--border-color); border-radius: 8px; color: #fff;">
          <div class="settings-help" style="margin-top: 8px;">
            Set the game length. Can only be changed before the game starts.
          </div>
        </div>
        <!-- Clear Recent Players -->
        <div class="settings-group" style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <label style="font-weight: 700;">Recent Players</label>
            <div class="settings-help">Remove all names from the "Recent players" list.</div>
          </div>
          <button type="button" id="clearRecentsBtn" class="btn btn-cancel" title="Clear Recent Players" style="background-color: #582828; border: 1px solid #8c4343; flex-shrink: 0; padding: 0; font-size: 1em; line-height: 1; width: 27px; height: 27px;">
            ‚úï
          </button>
        </div>
        <!-- Add to Home Screen button (shown when eligible) -->
        <div class="settings-group" id="installPromptGroup" style="display: none;">
          <button type="button" id="installBtnSettings" class="btn btn-confirm" style="display:none;">
            ‚ûï Add to Home Screen
          </button>
          <div class="settings-help">Install this app as a shortcut on your device.</div>
        </div>
        <div class="settings-group" style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <label style="font-weight: 700;">Clear Cache</label>
            <div class="settings-help">Forces the app to reload all its files from the server.</div>
          </div>
          <button type="button" id="clearCacheBtn" class="btn btn-cancel" title="Clear Cache & Refresh" style="background-color: #582828; border: 1px solid #8c4343; flex-shrink: 0; padding: 0; font-size: 1em; line-height: 1; width: 27px; height: 27px;">
            ‚úï
          </button>
        </div>
      </div>
      <div class="modal-footer">
        <div class="modal-actions">
          <button type="button" class="btn btn-cancel" onclick="closeSettings()">Close</button>
          <button type="button" class="btn btn-confirm" onclick="saveSettings()">Save</button>
        </div>
        <div class="settings-help" style="margin-top:8px;">Current: <b id="settingsSummary"></b></div>
      </div>
    </div>
  </div>

  <!-- iOS Add-to-Home instructions -->
  <div id="iosInstallOverlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="iosInstallTitle">
      <h3 id="iosInstallTitle">Add to Home Screen</h3>
      <p style="margin-top:6px;">
        On iPhone/iPad (Safari): tap the <b>Share</b> button, then choose <b>Add to Home Screen</b>.
      </p>
      <div class="modal-actions" style="margin-top:12px;">
        <button type="button" class="btn btn-confirm" onclick="closeIosInstall()">OK</button>
      </div>
    </div>
  </div>

  <!-- New Player Resolution Modal -->
  <div id="playerResolutionOverlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="playerResolutionTitle">
      <div class="modal-header">
        <h3 id="playerResolutionTitle">Player Found</h3>
      </div>
      <p id="playerResolutionMessage" style="margin-bottom: 16px;">Did you mean one of these players, or do you want to create a new one?</p>
      <ul id="playerResolutionList" class="player-resolution-list">
        <!-- Player options will be injected here -->
      </ul>
      <div class="modal-footer">
        <div class="modal-actions">
          <button type="button" class="btn btn-cancel" onclick="closePlayerResolution()">Cancel</button>
          <button type="button" id="createNewPlayerBtn" class="btn btn-confirm">Create New Player</button>
        </div>
      </div>
    </div>
  </div>
  <!-- New Player Stats Modal -->
  <div id="playerStatsOverlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="playerStatsTitle">
      <div class="modal-header">
        <h3 id="playerStatsTitle">Player Stats</h3>
      </div>
      <div class="settings-grid" style="padding: 0;">
        <div id="playerStatsContent" class="player-stats-grid">
          <!-- Content will be injected by JavaScript -->
          <div class="stat-block" style="grid-column: 1 / -1; text-align: center;">Loading...</div>
        </div>
      </div>
      <div class="modal-footer">
        <div class="modal-actions">
          <button type="button" class="btn btn-cancel" onclick="closePlayerStats()">Close</button>
        </div>
      </div>
    </div>
  </div>
  <!-- New Player Comparison Modal -->
  <div id="playerCompareOverlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="playerCompareTitle">
      <div class="modal-header">
        <h3 id="playerCompareTitle">COMPARE PLAYERS</h3>
      </div>
      <div class="comparison-select-wrap" style="display: none;">
        <select id="comparePlayer1" class="settings-input" style="width: 100%;">
          <option value="">Select Player 1</option>
        </select>
        <span class="vs-text">VS</span>
        <select id="comparePlayer2" class="settings-input" style="width: 100%;">
          <option value="">Select Player 2</option>
        </select>
      </div>
      <div id="comparisonResult" class="settings-grid" style="padding: 0;">
        <!-- Comparison results will be injected here -->
      </div>
      <div class="modal-footer">
        <div class="modal-actions">
          <button type="button" class="btn btn-cancel" onclick="closePlayerCompareModal()">Close</button>
        </div>
      </div>
    </div>
  </div>

  <!-- New container for stat delta animations -->
  <div id="statDeltaHost" class="stat-delta-container"></div>

  <!-- New Loading Overlay -->
  <div id="loadingOverlay" class="modal-overlay" style="background: rgba(0,0,0,0.8);">
    <div class="loading-content">
      <div class="spinner"></div>
      <div class="loading-text">Calculating Stats...</div>
    </div>
  </div>

  <!-- Toast host -->
  <div id="toastHost" class="toast-container" aria-live="polite" aria-atomic="true"></div>

  <!-- =========================================================
       SCRIPT: INITIAL SERVER STATE INJECTION
       ========================================================= -->
  <script>window.__gameCache = {{ game | tojson | safe }};</script>

  <!-- =========================================================
       SCRIPT: CONFIRM HELPER
       ========================================================= -->
  <script>
    (function(){
      const overlay = document.getElementById('confirmOverlay');
      const titleEl = document.getElementById('confirmTitle');
      const msgEl   = document.getElementById('confirmMessage');
      const okBtn   = document.getElementById('confirmOkBtn');
      const cancelBtn = document.getElementById('confirmCancelBtn');
      let resolvePromise = null;

      function openModal(opts){
        const { title='Confirm', message='Are you sure?', okText='OK', cancelText='Cancel' } = opts || {};
        titleEl.textContent = title;
        msgEl.textContent   = message;
        okBtn.textContent   = okText;
        cancelBtn.textContent = cancelText;
        overlay.classList.add('show');
        document.body.style.overflow = 'hidden';
        setTimeout(() => okBtn.focus(), 0);
        return new Promise(resolve => { resolvePromise = resolve; });
      }
      function closeModal(result){
        overlay.classList.remove('show');
        document.body.style.overflow = '';
        if (resolvePromise){ const r = resolvePromise; resolvePromise = null; r(result); }
      }
      okBtn.addEventListener('click', ()=> closeModal(true));
      cancelBtn.addEventListener('click', ()=> closeModal(false));
      overlay.addEventListener('click', (e)=>{ if(e.target === overlay) closeModal(false); }); // Close on backdrop click
      window.addEventListener('keydown', (e)=>{ if (overlay.classList.contains('show') && e.key === 'Escape') closeModal(false); });
      window.showConfirmModal = openModal;
    })();
  </script>

  <!-- =========================================================
       SCRIPT: TOAST HELPERS
       ========================================================= -->
  <script>
    function showToast(message, type='info', ms=2200){
      const host = document.getElementById('toastHost');
      function popButton(el) {
        if (!el) return;
        el.classList.add('pop-animation');
        el.addEventListener('animationend', () => el.classList.remove('pop-animation'), { once: true });
      }

      if(!host) return ()=>{};
      const t = document.createElement('div');
      t.className = 'toast toast--' + type;
      t.textContent = message;
      host.appendChild(t);
      requestAnimationFrame(()=> t.classList.add('show'));
      const remove = ()=> { t.classList.remove('show'); setTimeout(()=> t.remove(), 200); };
      setTimeout(remove, ms);
      return remove;
    }
    function showActionToast(message, actionText, onClick, type='info', ms=6000){
      const host = document.getElementById('toastHost');
      if(!host) return ()=>{};
      const t = document.createElement('div');
      t.className = 'toast toast--' + type;
      const span = document.createElement('span');
      span.textContent = message;
      const btn = document.createElement('button');
      btn.textContent = actionText;
      btn.addEventListener('click', ()=>{ try{ onClick(); }catch(e){} remove(); });
      t.appendChild(span); t.appendChild(btn);
      host.appendChild(t);
      requestAnimationFrame(()=> t.classList.add('show'));
      const remove = ()=> { t.classList.remove('show'); setTimeout(()=> t.remove(), 200); };
      setTimeout(remove, ms);
      return remove;
    }
  </script>

  <!-- =========================================================
       SCRIPT: HAPTIC FEEDBACK
       ========================================================= -->
  <script>
  (function(){
    const HAPTIC_KEY = 'darts-haptics-enabled';
    function isHapticsOn(){ const v = localStorage.getItem(HAPTIC_KEY); return v === null ? true : v === '1'; }
    function setHaptics(on){ localStorage.setItem(HAPTIC_KEY, on ? '1' : '0'); }
    window.hapticsPref = { isOn: isHapticsOn, set: setHaptics };

    let audioCtx;
    function ensureAudio(){
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        audioCtx = AC ? new AC() : null;
      }
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      return audioCtx;
    }
    function softClick(ms=70, freq=70){
      const ctx = ensureAudio(); if (!ctx) return;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'square';
      osc.frequency.value = freq;
      const t0 = ctx.currentTime;
      gain.gain.setValueAtTime(0, t0);
      gain.gain.linearRampToValueAtTime(0.16, t0 + 0.006);
      gain.gain.exponentialRampToValueAtTime(0.001, t0 + ms/1000);
      osc.connect(gain); gain.connect(ctx.destination);
      osc.start(t0); osc.stop(t0 + ms/1000 + 0.03);
    }
    function doubleClick(){ softClick(60, 85); setTimeout(()=> softClick(70, 60), 70); }

    const PATTERNS = { light:30, medium:[24,40,24], success:[20,40,20,50,70] };
    function tryVibrate(kind){
      if (!('vibrate' in navigator)) return false;
      const pattern = kind==='medium' ? PATTERNS.medium : (kind==='success' ? PATTERNS.success : PATTERNS.light);
      try{ return !!navigator.vibrate(pattern); }catch{ return false; }
    }

    window.haptic = function(kind='light'){
      if (!isHapticsOn()) return;
      const ok = tryVibrate(kind);
      if (ok) return;
      if (kind==='light') softClick(70, 70);
      else if (kind==='medium') doubleClick();
      else if (kind==='success'){ softClick(60, 90); setTimeout(()=> softClick(80, 50), 90); }
      else softClick(70, 70);
    };
    ['touchstart','mousedown','keydown'].forEach(ev=>{
      window.addEventListener(ev, ()=>{ ensureAudio(); }, { once:true, passive:true });
    });
    window.testHaptics = function(){
      const ok = tryVibrate('medium');
      if (!ok) doubleClick();
    };
  })();
  </script>

  <!-- =========================================================
       SCRIPT: PWA INSTALL (button lives in Settings)
       ========================================================= -->
  <script>
    (function(){
      const installPromptGroup = document.getElementById('installPromptGroup');
      const installBtn  = document.getElementById('installBtnSettings');
      const iosOverlay  = document.getElementById('iosInstallOverlay');
      let deferredPrompt = null;

      function isStandalone(){
        return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;
      }
      function isIOS(){ return /iPhone|iPad|iPod/i.test(navigator.userAgent); }
      function isSafari(){ return isIOS() && /Safari/i.test(navigator.userAgent) && !/CriOS|FxiOS|EdgiOS/i.test(navigator.userAgent); }

      function showInstallBtn(){
        // First, check if we are on a mobile device before showing anything.
        const isMobile = /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        if (!isMobile) return;

        if (installPromptGroup) installPromptGroup.style.display = 'grid';
        if (installBtn) installBtn.style.display = 'inline-block';
      }
      function hideInstallBtn(){ if (installBtn) installBtn.style.display = 'none'; }

      function openIosInstall(){
        if (!iosOverlay) return;
        iosOverlay.classList.add('show');
        document.body.style.overflow = 'hidden';
      }
      window.closeIosInstall = function(){
        if (!iosOverlay) return;
        iosOverlay.classList.remove('show');
        document.body.style.overflow = '';
      };

      window.updateInstallVisibility = function(){
        if (isStandalone()){ hideInstallBtn(); return; }
        if (deferredPrompt || isSafari()) showInstallBtn();
        else hideInstallBtn();
      };

      window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        window.updateInstallVisibility();
      });

      window.addEventListener('appinstalled', () => {
        hideInstallBtn();
        showToast('App installed! üéâ', 'success');
        deferredPrompt = null;
      });

      installBtn?.addEventListener('click', async () => {
        if (isStandalone()) { showToast('Already installed', 'warning'); hideInstallBtn(); return; }
        if (deferredPrompt) {
          deferredPrompt.prompt();
          try {
            const choice = await deferredPrompt.userChoice;
            if (choice && choice.outcome === 'accepted') {
              showToast('Installing‚Ä¶', 'warning');
            }
          } finally {
            deferredPrompt = null;
            setTimeout(window.updateInstallVisibility, 0);
          }
        } else if (isSafari()) {
          openIosInstall();
        } else {
          showToast('Install not supported in this browser', 'warning');
        }
      });

      document.addEventListener('DOMContentLoaded', window.updateInstallVisibility);
    })();
  </script>

  <!-- =========================================================
       SCRIPT: GLOBAL HELPER FUNCTIONS
       ========================================================= -->
  <script>
    function popButton(el) {
      if (!el) return;
      el.classList.add('pop-animation');
      el.addEventListener('animationend', () => el.classList.remove('pop-animation'), { once: true });
    }
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
    }
    function norm(s){ return (s||'').trim().replace(/\s+/g,' '); }

    async function apiFetch(url, options) {
      try {
        const response = await fetch(url, options);
        const contentType = response.headers.get('content-type');

        if (contentType && contentType.includes('application/json')) {
          return response.json(); // It's JSON, so parse and return it
        }

        // It's not JSON. This is an unexpected response, likely an HTML error page.
        // We can try to get the text to see what it is.
        const text = await response.text();
        if (text.toLowerCase().includes('<!doctype')) {
          throw new Error(`Server returned an HTML page instead of JSON. Status: ${response.status}`);
        }
        // Otherwise, it's some other non-JSON text
        throw new Error(`Server returned non-JSON response. Status: ${response.status}`);
      } catch (error) {
        // Re-throw the error to be caught by the calling function's catch block
        throw error;
      }
    }
  </script>

  {% if (game.phase == 'playing' or game.phase == 'playoff') and not show_stats %}
  <!-- =========================================================
       SCRIPT: PLAYING / PLAYOFF CLIENT RENDER & ACTIONS
       ========================================================= -->
  <script>
    function qs(s){ return document.querySelector(s); }

    // Wake Lock
    let wakeLock;
    async function keepAwake(on){
      try{
        if(on && 'wakeLock' in navigator){
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release',()=>{});
        } else {
          await wakeLock?.release();
          wakeLock = null;
        }
      }catch(e){}
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e)=>{
      const map = { '1':-3, '2':-2, '3':-1, '4':0, '5':+1, '6':+2, '0':0, 'u':'undo', 'U':'undo' };
      if(!(e.key in map)) return;
      e.preventDefault();
      if (map[e.key]==='undo') { undo(); return; }
      // For keyboard, we don't have a button to animate, so we pass `null`
      // to the hit function to prevent the page-pop animation.
      hit(map[e.key], null);
    });

    // Local save (resume)
    const SAVE_KEY='darts-golf-game';
    function saveLocal(game){ try{ localStorage.setItem(SAVE_KEY, JSON.stringify(game||{})); }catch(_){ } }
    function loadLocal(){ try{ return JSON.parse(localStorage.getItem(SAVE_KEY) || 'null'); }catch(_){ return null; } }

    // Track end state for confirm prompts
    let END_ACTIVE = {{ 'true' if game.end_after_round else 'false' }};

    function updateEndButtonLabel(active){
      var b = document.getElementById('endBtn');
      if (b) b.textContent = active ? 'Cancel' : 'End';
    }

    // ---- Anti-flicker sequencing + micro-batching ----
    let __opCounter = 0;
    let __lastCommittedOp = 0;
    let __applyTimer = null;

    function scheduleApplyFromServer(game, opId, force = false) {
      if (force) {
        __lastCommittedOp = Math.max(__lastCommittedOp, opId);
        window.__gameCache = game;
        saveLocal(game);
        renderGame(game);
        return;
      }
      if (opId !== __opCounter) return;
      if (__applyTimer) clearTimeout(__applyTimer);
      __applyTimer = setTimeout(() => {
        if (opId !== __opCounter) return;
        __lastCommittedOp = opId;
        window.__gameCache = game;
        saveLocal(game);
        renderGame(game);
      }, 64);
    }

    async function sendScore(val){
      const snapshot = window.__gameCache ? JSON.parse(JSON.stringify(window.__gameCache)) : null;
      const opId = ++__opCounter;

      try{
        // Optimistic
        if (window.__gameCache){
          const isPlayoff = window.__gameCache.phase === 'playoff';
          const playerToAnimate = isPlayoff ? window.__gameCache.playoff_group[window.__gameCache.current_player_index] : window.__gameCache.players[window.__gameCache.current_player_index];
          const playerIndexToAnimate = window.__gameCache.current_player_index; // For main game logic

          const g = JSON.parse(JSON.stringify(window.__gameCache));
          if (g.phase === 'playing'){
            const pIdx = g.current_player_index;
            const player = g.players[pIdx];
            const roundI = g.current_round - 1;

            g.round_history[roundI] = g.round_history[roundI] || {};
            g.scores[player] = (g.scores[player] || 0) + val;
            g.round_history[roundI][player] = val;

            g.undo_history = g.undo_history || [];
            g.undo_history.push({ player_index: pIdx, score_change: val });

            const lastIndex = g.players.length - 1;
            const wasLast   = pIdx === lastIndex;
            const isGameOver = wasLast && (g.current_round >= g.holes || g.end_after_round);

            if (!isGameOver) {
              g.current_player_index = wasLast ? 0 : pIdx + 1;
              if (wasLast) g.current_round += 1;
            } else {
              // Game is over, don't change round or player. Server will send final state.
            }
          } else if (g.phase === 'playoff'){
            const pIdx = g.current_player_index;
            const player = g.playoff_group[pIdx];
            g.playoff_round_scores = g.playoff_round_scores || {};
            g.playoff_round_scores[player] = val;
            // Only advance the index if it's not the last player in the group.
            const isLastPlayerOfRound = (pIdx === g.playoff_group.length - 1);
            if (isLastPlayerOfRound) {
              // Round is over. Server will resolve it. Optimistically reset for next round.
              g.playoff_round_scores = {};
              g.playoff_group = []; // The server will send the new, smaller group.
              g.current_player_index = 0;
            } else {
              g.current_player_index = pIdx + 1;
            }
          }
          window.__gameCache = g;
          saveLocal(g);
          renderGame(g);
          triggerDeltaAnimation(playerToAnimate, val, isPlayoff);
        }

        const data = await apiFetch('{{ url_for("api_score") }}', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({score:val}) });
        if (!data.ok){ if (__opCounter === opId && snapshot){ window.__gameCache = snapshot; renderGame(snapshot); __lastCommittedOp = opId; } showToast('Couldn‚Äôt save score ‚Äî server rejected', 'error'); return; }

        // If the server responds that the game is over, reload to show the final standings page.
        if (data.game.phase === 'final_ranking') {
          // Trigger the stat delta animations before reloading
          location.reload();
          return;
        }
        const force = (data.game.phase !== 'playing' || window.__gameCache.phase !== 'playing');
        scheduleApplyFromServer(data.game, opId, force);
      }catch(e){
        if (__opCounter === opId && snapshot){ window.__gameCache = snapshot; renderGame(snapshot); __lastCommittedOp = opId; }
        showToast('Couldn‚Äôt save score ‚Äî offline?', 'error');
        console.error('Score sync failed', e);
      }
    }

    async function undo(){
      const g0 = window.__gameCache;
      if (!g0 || g0.phase !== 'playing'){ showToast('Undo not available now', 'warning', 1400); return; }
      if (!g0.undo_history || !g0.undo_history.length){ showToast('Nothing to undo', 'warning', 1400); return; }

      const snapshot = JSON.parse(JSON.stringify(g0));
      const opId = ++__opCounter;

      try{
        const g = JSON.parse(JSON.stringify(g0));
        const n = g.players.length;

        const last_move = g.undo_history.pop();
        const prev_idx = (g.current_player_index - 1 + n) % n;
        g.current_player_index = prev_idx;

        if (prev_idx === n - 1){
          g.current_round = Math.max(1, g.current_round - 1);
        }

        const player_to_undo = g.players[prev_idx];
        const current_round_index = g.current_round - 1;
        g.scores[player_to_undo] = (g.scores[player_to_undo] || 0) - (last_move.score_change || 0);
        g.round_history[current_round_index] = g.round_history[current_round_index] || {};
        delete g.round_history[current_round_index][player_to_undo];

        window.__gameCache = g;
        saveLocal(g);
        renderGame(g);

        const data = await apiFetch('{{ url_for("api_undo") }}', { method:'POST' });
        if (!data.ok){ if (__opCounter === opId){ window.__gameCache = snapshot; renderGame(snapshot); __lastCommittedOp = opId; } showToast('Undo failed ‚Äî server rejected', 'error'); return; }

        const force = (data.game.phase !== 'playing' || window.__gameCache.phase !== 'playing');
        scheduleApplyFromServer(data.game, opId, force);
      }catch(e){
        if (__opCounter === opId){ window.__gameCache = snapshot; renderGame(snapshot); __lastCommittedOp = opId; }
        showToast('Undo failed ‚Äî offline?', 'error');
        console.error('Undo sync failed', e);
      }
    }

    async function toggleEnd(){
      if (!END_ACTIVE) {
        const ok = await window.showConfirmModal({ title: 'End', message: 'The game will end after ALL players finish THIS round. Continue?', okText: 'End', cancelText: 'Cancel' });
        if (!ok) return;
      } else {
        const ok = await window.showConfirmModal({ title: 'Cancel End', message: 'The game will continue normally after this round. Continue?', okText: 'Cancel End', cancelText: 'Keep Ending' });
        if (!ok) return;
      }
      const data = await apiFetch('{{ url_for("api_end_after_round") }}', {method:'POST'});
      if(!data.ok) return;
      window.__gameCache = data.game;
      saveLocal(data.game);
      renderGame(data.game);
    }

    function renderGame(g){
      keepAwake(g.phase==='playing' || g.phase==='playoff');

      if(g.phase==='playing'){ renderPlaying(g); var u=qs('#undoBtn'); if(u) u.removeAttribute('disabled'); }
      else if(g.phase==='playoff'){ renderPlayoff(g); var u2=qs('#undoBtn'); if(u2) u2.setAttribute('disabled','disabled'); }

      END_ACTIVE = !!g.end_after_round;
      updateEndButtonLabel(END_ACTIVE);
    }

    // Function to trigger the delta animation on a specific cell
    function triggerDeltaAnimation(scoredPlayerName, scoreValue, isPlayoff) {
      let targetCell;
      const game = window.__gameCache; // Get current game state

      if (isPlayoff) {
        const headerThs = document.querySelectorAll('#scoreboard thead th:not(:first-child)');
        const colIndex = Array.from(headerThs).findIndex(th => th.dataset.playerName === scoredPlayerName);

        if (colIndex !== -1) {
          targetCell = document.querySelector(`#scoreboard .current-row td:nth-child(${colIndex + 2})`);
          if (targetCell) {
            // The cell was rendered empty. Now we fill it and animate it.
            const v = scoreValue;
            const signedV = (v > 0 ? '+' : '') + v;
            const deltaClass = v > 0 ? 'pos' : (v < 0 ? 'neg' : 'zero');

            // 1. Populate the cell's inner HTML with the score and delta elements.
            targetCell.innerHTML = `
              <div class="cell">
                <span class="total-pill">${signedV}</span>
                <span class="delta-corner ${deltaClass}">${signedV}</span>
              </div>
            `;

            // 2. Find the newly created delta corner and trigger its animation.
            const deltaCorner = targetCell.querySelector('.delta-corner');
            if (deltaCorner) {
              deltaCorner.classList.add('delta-animate-trigger');
              deltaCorner.addEventListener('animationend', () => deltaCorner.classList.remove('delta-animate-trigger'), { once: true });
            }
          }
        }
      } else {
        // Main game logic remains the same, as it works correctly.
        const roundRow = document.querySelector(`#scoreboard tbody tr:nth-child(2)`);
        targetCell = roundRow?.querySelectorAll('td')[game.current_player_index - 1];
        const deltaCorner = targetCell?.querySelector('.delta-corner');
        if (deltaCorner) {
          deltaCorner.classList.add('delta-animate-trigger');
          deltaCorner.addEventListener('animationend', () => deltaCorner.classList.remove('delta-animate-trigger'), { once: true });
        }
      }
    }

    function animateStatDeltas(deltas) {
      const host = document.getElementById('statDeltaHost');
      if (!host) return;

      Object.entries(deltas).forEach(([playerName, playerDeltas]) => {
        const deltaEl = document.createElement('div');
        deltaEl.className = 'stat-delta-item';
        
        let html = `<div class="player-name">${escapeHtml(playerName)}</div>`;
        if (playerDeltas.wins > 0) {
          html += `<div class="delta-line good">üèÜ Win! <span>+1</span></div>`;
        }
        if (playerDeltas.total_birdies > 0) {
          html += `<div class="delta-line good">üïäÔ∏è Birdies <span>+${playerDeltas.total_birdies}</span></div>`;
        }
        if (playerDeltas.total_bogeys > 0) {
          html += `<div class="delta-line bad">üíî Bogeys <span>+${playerDeltas.total_bogeys}</span></div>`;
        }

        deltaEl.innerHTML = html;
        host.appendChild(deltaEl);

        // Animate in
        requestAnimationFrame(() => {
          deltaEl.style.opacity = '1';
          deltaEl.style.transform = 'translateY(0) scale(1)';
        });

        // Animate out and remove
        setTimeout(() => {
          deltaEl.style.opacity = '0';
          deltaEl.style.transform = 'translateY(-20px) scale(0.95)';
          deltaEl.addEventListener('transitionend', () => deltaEl.remove());
        }, 1800); // Start fading out before the full reload
      });
    }

    function sign(v){ return v>0?'+':''; }

// Refactored function to update the info bar elements
    function updateInfoBar(g) {
      const infoBar = qs('#info-bar');
      if (!infoBar) return;

      const roundCountDiv = infoBar.querySelector('.round-count');
      const oldDigitSpan = roundCountDiv.querySelector('.old-digit');
      const newDigitSpan = roundCountDiv.querySelector('.new-digit');
      const roundLabelSpan = roundCountDiv.querySelector('.round-label');
      const roundTotalSpan = roundCountDiv.querySelector('.round-total');
      const turnInfoDiv = infoBar.querySelector('.turn-info');

      // Determine current round number and label based on phase
      let currentRoundValue;
      let roundLabelText;
      let roundTotalText = '';
      let turnInfoText = '';

      if (g.phase === 'playing') {
        currentRoundValue = g.current_round;
        roundLabelText = 'ROUND';
        roundTotalText = `/ ${g.holes}`;
        turnInfoText = g.end_after_round ? 'FINAL ROUND' : `${g.players[g.current_player_index]}'s Turn`;
      } else if (g.phase === 'playoff') {
        currentRoundValue = g.playoff_round;
        roundLabelText = 'TIE-BREAKER';
        roundTotalText = ''; // No total rounds in playoff
        if (g.playoff_group && g.playoff_group.length > 0) {
          turnInfoText = `${g.playoff_group[g.current_player_index]}'s Turn`;
        } else {
          turnInfoText = 'Resolving...'; // Show a generic message while waiting for the server
        }
      } else {
        return; // Not in a phase that uses this info bar
      }

      // Update Round Label
      roundLabelSpan.textContent = roundLabelText;

      // Update Round Number with animation
      const oldRoundNumberText = oldDigitSpan.textContent;
      const newRoundNumberText = String(currentRoundValue).padStart(2,'0');

      if (oldRoundNumberText !== newRoundNumberText) {
        // Set the new value to the new digit element
        newDigitSpan.textContent = newRoundNumberText;

        // Immediately reset newDigitSpan's position without transition to prepare for animation
        newDigitSpan.style.transition = 'none';
        newDigitSpan.style.transform = 'translateY(100%)'; // Start below
        newDigitSpan.style.opacity = '0';

        // Force reflow to apply the immediate reset before starting the actual animation
        void newDigitSpan.offsetWidth;

        // Enable transitions for the animation
        oldDigitSpan.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
        newDigitSpan.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';

        // Start the animation
        oldDigitSpan.style.transform = 'translateY(-100%)';
        oldDigitSpan.style.opacity = '0';
        newDigitSpan.style.transform = 'translateY(0)';
        newDigitSpan.style.opacity = '1';

        // Update oldDigitSpan's text content immediately for logical state,
        // but visually it will still be the old number animating out.
        // This prevents re-triggering if updateInfoBar is called again before transitionend.
        oldDigitSpan.textContent = newRoundNumberText;

        // Clean up after animation completes
        newDigitSpan.addEventListener('transitionend', function handler() {
          newDigitSpan.removeEventListener('transitionend', handler); // Remove listener

          // Reset oldDigitSpan to its final visible state (it already has the correct text)
          oldDigitSpan.style.transform = 'translateY(0)';
          oldDigitSpan.style.opacity = '1';
          oldDigitSpan.style.transition = 'none'; // Disable transition for the reset

          // Reset newDigitSpan to its hidden, empty state
          newDigitSpan.textContent = ''; // Clear content
          newDigitSpan.style.transform = 'translateY(100%)';
          newDigitSpan.style.opacity = '0';
          newDigitSpan.style.transition = 'none'; // Disable transition for immediate reset
        }, { once: true });
      } else {
        // If no change, ensure old digit is visible and new digit is hidden/empty
        oldDigitSpan.textContent = newRoundNumberText;
        oldDigitSpan.style.transform = 'translateY(0)';
        oldDigitSpan.style.opacity = '1';
        oldDigitSpan.style.transition = 'none'; // Ensure no lingering transitions

        newDigitSpan.textContent = ''; // Ensure new digit is empty
        newDigitSpan.style.transform = 'translateY(100%)';
        newDigitSpan.style.opacity = '0';
        newDigitSpan.style.transition = 'none'; // Ensure no lingering transitions
      }
      if (g.phase === 'playing') {
        roundTotalSpan.textContent = roundTotalText;
        roundTotalSpan.style.display = '';
      } else {
        roundTotalSpan.style.display = 'none';
      }

      // 3. Update Turn Info
      turnInfoDiv.textContent = turnInfoText;

      // 4. Update the info bar's appearance based on the 'ending' state
      if (g.end_after_round) {
        infoBar.classList.add('ending');
      } else {
        infoBar.classList.remove('ending');
      }
    }

    function renderPlaying(g){
      updateInfoBar(g); // Update the info bar elements

      var useInitials = g.players.length > 4;
      var headers = g.players.map(function(p, i) {
        var displayName = useInitials
          ? p.split(' ').map(function(w) { return w[0] || ''; }).join('').toUpperCase()
          : p;
        var isCurrent = i === g.current_player_index;
        return '<th class="'+(isCurrent ? 'current-player-header' : '')+'">'+displayName+'</th>';
      }).join('');
      var thead = '<thead><tr><th>&nbsp;</th>' + headers + '</tr></thead>';

      var totals = g.players.map(function(p){
        var s = g.scores[p] || 0;
        return '<td>'+sign(s)+s+'</td>';
      }).join('');

      var tbody = '<tbody><tr class="total-row"><th>Total</th>'+totals+'</tr>';

      var justWrappedRound = g.current_player_index === 0 && g.current_round > 1;

      var curIdx = g.current_round - 1;
      var curRow = g.round_history[curIdx] || {};
      var currentCells = g.players.map(function(p, pIdx){
        var v = curRow[p]; // Score for this player in this round
        var isCurrentPlayerForCell = (pIdx === g.current_player_index && typeof v === 'undefined');
        if (typeof v === 'undefined') {
          // This is an empty cell, apply highlight if it's the current player's turn
          return '<td class="' + (isCurrentPlayerForCell ? 'current-player-cell' : '') + '">' +
                 '<div class="cell"><span class="total-pill">0</span><span class="delta-corner hidden">0</span></div>' +
                 '</td>';
        }
        // This cell has a score, render it normally
        var running = g.round_history.slice(0, g.current_round).reduce(function(sum, rh){ return sum + (rh[p]||0); }, 0);
        return '<td><div class="cell"><span class="total-pill">'+(running>0?'+':'')+running+'</span><span class="delta-corner '+(v>0?'pos':(v<0?'neg':'zero'))+'">'+(v>0?'+':'')+v+'</span></div></td>';
      }).join('');
      tbody += '<tr class="current-row"><th>'+String(g.current_round).padStart(2,'0')+'</th>'+currentCells+'</tr>';

      for(var i=g.current_round-2;i>=0;i--){
        var row = g.round_history[i] || {}; // This is a past round, no highlight needed.
        var cells = g.players.map(function(p) {
          var v = row[p];
          if (typeof v === 'undefined') return '<td></td>';
          var running = g.round_history.slice(0, i + 1).reduce(function(sum, rh) { return sum + (rh[p] || 0); }, 0);
          return '<td><div class="cell"><span class="total-pill">' + (running > 0 ? '+' : '') + running + '</span><span class="delta-corner ' + (v > 0 ? 'pos' : (v < 0 ? 'neg' : 'zero')) + '">' + (v > 0 ? '+' : '') + v + '</span></div></td>';
        }).join('');
        tbody += '<tr><th>'+String(i+1).padStart(2,'0')+'</th>'+cells+'</tr>';
      }

      tbody += '</tbody>';
      qs('#scoreboard').innerHTML = thead+tbody;
    }

    function renderPlayoff(g){
        updateInfoBar(g); // Update the info bar elements
        // ---- Build a stable header list (all players who ever appeared in this tie) ----
        var headerPlayers = g.playoff_pool || []; // Use the stable pool
        var curScores = g.playoff_round_scores || {};

        // THEAD with current shooter highlight when applicable
        var useInitials = headerPlayers.length > 4;
        var thead = '<thead><tr><th>&nbsp;</th>'+headerPlayers.map(function(p) {
          var isCur = (g.playoff_group && p === g.playoff_group[g.current_player_index]);
          var displayName = useInitials
            ? p.split(' ').map(function(w) { return w[0] || ''; }).join('').toUpperCase()
            : p;
          return '<th class="'+(isCur ? 'current-player-header' : '')+'" data-player-name="'+p+'">' + displayName + '</th>';
        }).join('')+'</tr></thead>';

        // TB totals (base score only)
        var totals = headerPlayers.map(function(){ var s = g.playoff_base_score || 0; return '<td>'+(s>0?'+':'')+s+'</td>'; }).join('');
        var tbody = '<tbody><tr class="total-row"><th>Total</th>'+totals+'</tr>';

        // ‚úÖ Current TB round row (stable columns)
        var currentCells = headerPlayers.map(function(p) {
          var v = curScores[p];
          // Determine if this cell belongs to the current player whose turn it is
          var isCurrentPlayerForCell = (g.playoff_group && p === g.playoff_group[g.current_player_index]);
          // For the player who just scored, render an empty cell. The animation function will fill it.
          // For all other players, render as normal.
          if (typeof v === 'undefined') {
            // Render an empty cell with the highlight if it's the current player's turn
            return '<td class="'+(isCurrentPlayerForCell ? 'current-player-cell' : '')+'"><div class="cell"><span class="total-pill"></span><span class="delta-corner hidden"></span></div></td>';
          }
          return '<td><div class="cell"><span class="total-pill">' + (v > 0 ? '+' : '') + v + '</span><span class="delta-corner ' + (v > 0 ? 'pos' : (v < 0 ? 'neg' : 'zero')) + '">' + (v > 0 ? '+' : '') + v + '</span></div></td>';
        }).join('');
        tbody += '<tr class="current-row"><th>TB '+String(g.playoff_round).padStart(2,'0')+'</th>'+currentCells+'</tr>';

      // üîÅ Past completed TB rounds (latest first)
      for (var idx = g.playoff_history.length - 1; idx >= 0; idx--) {
        var round_scores = g.playoff_history[idx] || {};
        var tbNum = idx + 1;
        var cells = headerPlayers.map(function(p){ // Use stable headerPlayers list
          var v = round_scores[p];
          if (typeof v === 'undefined') return '<td></td>';
          return (
            '<td>' +
              '<div class="cell">' +
                '<span class="total-pill">' + (v>0?'+':'') + v + '</span>' +
                '<span class="delta-corner ' + (v>0?'pos':(v<0?'neg':'zero')) + '">' + (v>0?'+':'') + v + '</span>' +
              '</div>' +
            '</td>'
          );
        }).join('');
        tbody += '<tr><th>TB ' + String(tbNum).padStart(2,'0') + '</th>' + cells + '</tr>';
      }


        tbody += '</tbody>';
        qs('#scoreboard').innerHTML = thead + tbody;
      }

    function hit(val, el){
      if (el) { // Only animate and position bubble if an element is provided
        popButton(el);
        showBubbleFor(val, el);
      } else {
        // For keyboard input, show bubble from the bottom of the screen
        showBubbleFor(val, null);
      }
      sendScore(val);
    }
    function showBubbleFor(val, el){
      // 1. Get the label text for the bubble
      const scoreLabels = window.__gameCache?.score_labels || {};
      var key = String(val), label = (typeof scoreLabels[key] !== 'undefined') ? scoreLabels[key] : (val>0?('+'+val):String(val));
      var cls = val > 0 ? 'pos' : (val < 0 ? 'neg' : 'zero');

      // 2. Create the bubble and add it to the DOM to measure it
      const bubble = document.createElement('div');
      bubble.className = `score-bubble ${cls}`;
      bubble.textContent = label;
      document.body.appendChild(bubble);

      // 3. Calculate its position, keeping it on-screen
      const rect = el?.getBoundingClientRect();
      const bubbleWidth = bubble.offsetWidth;
      const margin = 8; // 8px margin from screen edge

      // Default to center of button, or center of screen for keyboard input
      let x = rect ? rect.left + (rect.width / 2) : window.innerWidth / 2;
      let y = rect ? rect.top - 6 : window.innerHeight - 80;

      // Adjust x to prevent overflow
      x = Math.max(x, (bubbleWidth / 2) + margin); // Keep left edge on screen
      x = Math.min(x, window.innerWidth - (bubbleWidth / 2) - margin); // Keep right edge on screen

      bubble.style.left = `${x}px`; // The CSS transform will handle the centering
      bubble.style.top = `${y}px`;
      bubble.addEventListener('animationend', () => bubble.remove());
    }

    // --- Init on load ---
    document.addEventListener('DOMContentLoaded', () => {
      keepAwake(true);
      updateEndButtonLabel(END_ACTIVE);
    });
  </script>
  {% elif game.phase == 'setup' and not show_stats %}
  <!-- =========================================================
       SCRIPT: SETUP PAGE ‚Äî Pills with Pointer Events drag
       ========================================================= -->
  <script>
    const chipList         = document.getElementById('chipList');           // recent chips (if any)
    const selectedWrap     = document.getElementById('selectedWrap'); // container for selected chips
    const selectedChipList = document.getElementById('selectedChipList');
    const playersHidden    = document.getElementById('playersInput');       // hidden CSV posted to /start
    const nameField        = document.getElementById('nameField');
    const addNameBtn       = document.getElementById('addNameBtn');
    const startForm        = document.getElementById('startForm');

    const SETUP_PLAYERS_KEY = 'darts-golf-setup-players';
    let selected = [];
    try {
      const saved = sessionStorage.getItem(SETUP_PLAYERS_KEY);
      if (saved) {
        selected = JSON.parse(saved);
      }
    } catch(e) {
      console.warn('Could not load setup players from session storage.');
      selected = [];
    }

    let allRecentNames = {{ (game.recent_names or []) | tojson | safe }};
    
    // ---------- Rendering ----------
    function renderSelected(){
      if (selected.length) {
        selectedChipList.innerHTML = selected.map((p, i) => (
          `<div class="chip draggable" data-name="${escapeHtml(p.name)}" data-id="${p.id}" title="Drag to reorder">
             <span class="chip-index">${i+1}</span>
             <span class="chip-name">${escapeHtml(p.name)}</span>
             <button type="button" class="chip-remove" aria-label="Remove ${escapeHtml(p.name)}" title="Remove">‚úï</button>
           </div>`
        )).join('');
      } else {
        selectedChipList.innerHTML = '<div class="empty-list-text">empty</div>';
      }
      bindSelectedEvents();
      writeHidden();
      renderRecent(); // Re-render recents to show/hide selected names
    }

    function renderRecent(){
      if (!chipList) return;
      const availableRecents = allRecentNames.filter(name => !selected.some(p => p.name.toLowerCase() === name.toLowerCase()));

      if (availableRecents.length > 0) {
        chipList.innerHTML = availableRecents.map(n =>
          `<div class="chip" data-name="${escapeHtml(n)}">${escapeHtml(n)}</div>`
        ).join('');
      } else {
        chipList.innerHTML = '<div class="empty-list-text">No recent players</div>';
      }

      chipList.querySelectorAll('.chip[data-name]').forEach(el=>{
        el.addEventListener('click', ()=>{
          const name = el.getAttribute('data-name');
          addPlayer(name, true); // Pass true to indicate it's from the recent list
        });
      });
    }

    function writeHidden(){
      // Correctly map the array of player objects to a string of IDs.
      playersHidden.value = selected.map(p => p.id).join(',');
      // Also save the current selection to session storage
      try {
        sessionStorage.setItem(SETUP_PLAYERS_KEY, JSON.stringify(selected));
      } catch(e) { console.warn('Could not save setup players to session storage.'); }
    }

    // ---------- Add / Remove Logic ----------
    async function addPlayer(raw, isFromRecent = false){
      const name = norm(raw);
      if (!name) return;
      if (name.length > 14) {
        showToast('Name cannot be longer than 14 characters.', 'warning', 3000);
        return;
      }
      if (selected.some(p => p.name.toLowerCase() === name.toLowerCase())) {
        showToast(`${name} is already in the game.`, 'warning');
        return;
      }

      try {
        const data = await apiFetch(`/api/resolve-player/${encodeURIComponent(name)}`);

        if (!data.ok) throw new Error(data.error || 'Server error');

        // If the user clicked a recent player, or if there's a single exact match, add it directly.
        if (data.exact_match && (isFromRecent || data.suggestions.length === 0)) {
          commitAddPlayer(data.exact_match);
        }
        // If there are suggestions but no exact match, show the resolution prompt.
        else if (data.suggestions.length > 0) {
          openPlayerResolution(name, data.suggestions);
        }
        // Otherwise, no matches were found, so create a new player.
        else {
          const createData = await apiFetch('/api/create-player', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ name }) });
          if (!createData.ok) throw new Error(createData.error || 'Failed to create player');
          commitAddPlayer(createData.player);
        }

      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }

    function commitAddPlayer(player) {
      if (!player || !player.id || !player.name) return;
      // Final check for duplicates before adding
      if (selected.some(p => p.id === player.id)) {
        showToast(`${player.name} is already in the game.`, 'warning');
        return;
      }
      selected.push(player);
      renderSelected();
      nameField.value = ''; // Clear input field
      nameField.focus();
      haptic('light');
      closePlayerResolution(); // Ensure resolution modal is closed
    }

    function removePlayer(name){
      const i = selected.findIndex(p => p.name.toLowerCase() === name.toLowerCase());
      if (i >= 0){
        selected.splice(i,1);
        renderSelected(); // re-number pills
      }
    }

    function removePlayerById(id){
      const i = selected.findIndex(p => p.id === id);
      if (i >= 0){
        selected.splice(i,1);
        renderSelected(); // re-number pills
      }
    }

    // Delegated click for ‚úï remove
    selectedChipList.addEventListener('click', (e)=>{
      const btn = e.target.closest('.chip-remove');
      if (!btn) return;
      e.preventDefault();
      e.stopPropagation();
      const chip = btn.closest('.draggable');
      if (chip) removePlayerById(chip.getAttribute('data-id'));
    });

    // ---------- Helpers ----------
    // `idxOfName` is no longer needed as we use `findIndex` on objects.
    // ---------- Desktop HTML5 DnD fallback (only if no Pointer Events) ----------
    function bindSelectedEvents(){
      const hasPointer = 'PointerEvent' in window;
      selectedChipList.querySelectorAll('.draggable').forEach(chip=>{
        if (!hasPointer){
          chip.setAttribute('draggable','true');
          chip.addEventListener('dragstart', (e)=>{ chip.classList.add('dragging'); e.dataTransfer.effectAllowed='move'; });
          chip.addEventListener('dragend',   ()=> chip.classList.remove('dragging'));
        } else {
          chip.removeAttribute('draggable'); // prevent native DnD when using Pointer Events
        }
      });

      if (!hasPointer) {
        selectedChipList.addEventListener('dragover', (e)=>{
          e.preventDefault();
          const after = getAfter(selectedChipList, e.clientY);
          const dragging = selectedChipList.querySelector('.dragging');
          if (!dragging) return;
          if (!after) selectedChipList.appendChild(dragging);
          else selectedChipList.insertBefore(dragging, after);
        });
        selectedChipList.addEventListener('drop', ()=>{
          commitOrderFromDom(); // re-render to update numbering
        });
      }
    }

    function getDropTarget(container, y){
      const els = [...container.querySelectorAll('.draggable:not(.dragging)')];
      return els.reduce((closest, child)=>{
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height/2;
        return (offset < 0 && offset > closest.offset) ? {offset, element: child} : closest;
      }, {offset: Number.NEGATIVE_INFINITY, element: null}).element;
    }

    // ---------- Pointer Events drag (modern browsers) ----------
    ;(function(){
      if (!('PointerEvent' in window)) return;
      if (!document.getElementById('selectedChipList')) return;

      let active = null;        // element being dragged (original)
      let ghost = null;         // floating clone
      let placeholder = null;   // insertion marker
      let startX=0, startY=0;   // pointer down pos
      let offX=0, offY=0;       // offset within chip
      let dragging = false;
      let pointerId=null;

      const TOUCH_SLOP_SQ = 25; // 5px^2 threshold for touch
      function setBodyCursor(grabbing){ document.body.style.cursor = grabbing ? 'grabbing' : ''; }

      function createGhost(fromEl){
        const r = fromEl.getBoundingClientRect();
        const g = fromEl.cloneNode(true);
        g.style.position = 'fixed';
        g.style.left = r.left + 'px';
        g.style.top  = r.top  + 'px';
        g.style.width = r.width + 'px';
        g.style.height = r.height + 'px';
        g.style.pointerEvents = 'none';
        g.style.opacity = '0.85';
        g.style.boxSizing = 'border-box';
        g.classList.add('dragging');
        document.body.appendChild(g);
        return g;
      }
      function makePlaceholder(fromEl){
        const p = document.createElement('div');
        p.className = 'chip placeholder';
        p.style.width  = fromEl.offsetWidth + 'px';
        p.style.height = fromEl.offsetHeight + 'px';
        return p;
      }
      function indexFromPoint(x, y){
        const children = Array.from(selectedChipList.children).filter(el => el !== placeholder);
        if (!children.length) return 0;
        let bestIdx = children.length;
        let bestDist = Infinity;
        children.forEach((el, idx)=>{
          const r = el.getBoundingClientRect();
          const cx = r.left + r.width/2;
          const cy = r.top + r.height/2;
          const dx = cx - x, dy = cy - y;
          const d  = dx*dx + dy*dy;
          if (d < bestDist){ bestDist = d; bestIdx = idx; }
        });
        const near = children[bestIdx];
        if (!near) return children.length;
        const r = near.getBoundingClientRect();
        const before =
          (Math.abs(y - (r.top + r.height/2)) > Math.abs(x - (r.left + r.width/2)))
            ? (y < r.top + r.height/2)
            : (x < r.left + r.width/2);
        return before ? bestIdx : bestIdx + 1;
      }
      function commitOrderFromDom(){
        selected = Array
          .from(selectedChipList.querySelectorAll('.draggable'))
          .map(el => ({ id: el.dataset.id, name: el.dataset.name }));
        writeHidden();
        renderSelected(); // re-number after reorder
      }

      function startDrag(){
        if (!active || dragging) return;
        ghost = createGhost(active);
        placeholder = makePlaceholder(active);
        selectedChipList.insertBefore(placeholder, active);
        active.style.visibility = 'hidden'; // keep layout size; avoids jump
        dragging = true;
        setBodyCursor(true);
      }

      function onPointerDown(e){
        e.preventDefault();
        const rmBtn = e.target.closest('.chip-remove');
        if (rmBtn) return;

        const chip = e.target.closest('.draggable');
        if (!chip) return;

        active = chip;
        pointerId = e.pointerId;
        try { active.setPointerCapture(pointerId); } catch(_){ }

        const r = chip.getBoundingClientRect();
        startX = e.clientX; startY = e.clientY;
        offX = startX - r.left; offY = startY - r.top;
        dragging = false;

        if (e.pointerType === 'mouse') {
          startDrag();
        }
      }

      function onPointerMove(e){
        if (!active) return;

        if (!dragging){
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          const dist2 = dx*dx + dy*dy;
          if (e.pointerType !== 'mouse' && dist2 <= TOUCH_SLOP_SQ) return;
          startDrag();
        }

        e.preventDefault();
        const x = e.clientX - offX, y = e.clientY - offY;
        if (ghost){
          ghost.style.left = x + 'px';
          ghost.style.top  = y + 'px';
        }

        const idx = indexFromPoint(e.clientX, e.clientY);
        const target = document.getElementById('selectedChipList').children[idx];
        if (!target) selectedChipList.appendChild(placeholder);
        else selectedChipList.insertBefore(placeholder, target);
      }

      function onPointerUp(e){
        if (!active) return;

        if (dragging){
          if (placeholder && placeholder.parentNode){
            selectedChipList.insertBefore(active, placeholder);
          }
          active.style.visibility = '';
          placeholder?.remove(); placeholder = null;
          ghost?.remove(); ghost = null;
          commitOrderFromDom();
        }

        try { active.releasePointerCapture(pointerId); } catch(_){ }
        active = null;
        dragging = false;
        pointerId = null;
        setBodyCursor(false);
      }

      document.getElementById('selectedChipList').addEventListener('pointerdown', onPointerDown, { passive:false });
      window.addEventListener('pointermove', onPointerMove, { passive:false });
      window.addEventListener('pointerup', onPointerUp, { passive:false });
      window.addEventListener('pointercancel', onPointerUp, { passive:false });
      window.addEventListener('blur', onPointerUp, { passive:false });
    })();

    // ---------- Form UX ----------
    addNameBtn.addEventListener('click', ()=> addPlayer(nameField.value));
    nameField.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter'){
        e.preventDefault();
        e.stopPropagation(); // Stop the event from bubbling up to the form
        addPlayer(nameField.value);
      }
    });
    
    startForm.addEventListener('submit', (e)=>{
      if (!selected.length){
        e.preventDefault();
        showToast('Add at least one player', 'warning', 1600);
        nameField.focus();
        return;
      }
      // Clear the saved players from session storage on successful submission
      sessionStorage.removeItem(SETUP_PLAYERS_KEY);
      // The `writeHidden()` function is called on every render, so this is no longer needed.
    });

    // ---------- Init ----------
    renderRecent();
    renderSelected();

    // --- Player Resolution Modal Logic ---
    const resolutionOverlay = document.getElementById('playerResolutionOverlay');
    const resolutionList = document.getElementById('playerResolutionList');
    const createNewBtn = document.getElementById('createNewPlayerBtn');
    let originalNameForCreation = '';

    function openPlayerResolution(originalName, suggestedPlayers) {
      originalNameForCreation = originalName;
      createNewBtn.textContent = `Create New Player: "${escapeHtml(originalName)}"`; // Update button text
      resolutionList.innerHTML = suggestedPlayers.map(p => 
        `<li data-player-id="${p.id}" data-player-name="${escapeHtml(p.name)}">${escapeHtml(p.name)}</li>`
      ).join('');
      resolutionOverlay.classList.add('show');
    }

    function closePlayerResolution() {
      resolutionOverlay.classList.remove('show');
      createNewBtn.textContent = 'Create New Player'; // Reset button text
      originalNameForCreation = '';
    }

    resolutionList.addEventListener('click', (e) => {
      const li = e.target.closest('li');
      if (!li) return;
      const player = { id: li.dataset.playerId, name: li.dataset.playerName };
      commitAddPlayer(player);
    });

    createNewBtn.addEventListener('click', async () => {
      if (!originalNameForCreation) return;
      const createData = await apiFetch('/api/create-player', { method: 'POST', headers: {'Content-Type': 'application/json'}, body: JSON.stringify({ name: originalNameForCreation }) });
      if (!createData.ok) { showToast(createData.error || 'Failed to create player', 'error'); return; }
      commitAddPlayer(createData.player);
    });
  </script>
  {% endif %}

  {% if game.phase == 'final_ranking' and not show_stats %}
  <!-- =========================================================
       SCRIPT: CONFETTI ON WINNER
       ========================================================= -->
  <script id="confetti-script">
    (function(){
      const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReduced) return;

      const canvas = document.getElementById('confettiCanvas');
      const ctx = canvas.getContext('2d');
      let W, H, raf = null;
      let pieces = [];
      function resize(){ W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
      window.addEventListener('resize', resize); resize();

      function spawn(n){
        for(let i=0;i<n;i++){
          pieces.push({
            x: Math.random() * W, y: -20 - Math.random() * 20, // Start from just above the top, across the whole width
            vx: (Math.random()-0.5)*1, vy: 2+Math.random()*3,
            size: 5+Math.random()*8, rot: Math.random()*Math.PI, vr: (Math.random()-0.5)*0.2,
            shape: Math.random()<0.5?'rect':'tri',
            life: 2.0,
            fade: 0.002 + Math.random() * 0.005 // Make them last longer to reach the bottom
          });
        }
      }
      function step(){
        ctx.clearRect(0,0,W,H);
        let i = pieces.length;
        while (i--) {
          const p = pieces[i];
          p.life -= p.fade;
          if (p.life <= 0) {
            pieces.splice(i, 1);
            continue;
          }
          p.vy += 0.02; p.x += p.vx; p.y += p.vy; p.rot += p.vr; // A little more gravity
          ctx.save();
          ctx.globalAlpha = p.life;
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = ['#E3292E','#309F6A','#F9DFBC','#ffffff','#ffd54f'][Math.floor(Math.random()*5)];
          if (p.shape==='rect'){ ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6); }
          else {
            ctx.beginPath();
            ctx.moveTo(0,-p.size/2); ctx.lineTo(p.size/2,p.size/2); ctx.lineTo(-p.size/2,p.size/2); ctx.closePath(); ctx.fill();
          }
          ctx.restore();
        }

        if (pieces.length > 0) {
          raf = requestAnimationFrame(step);
        } else {
          ctx.clearRect(0,0,W,H); // Final clear
          cancelAnimationFrame(raf);
          raf = null;
        }
      }
      spawn(300); // A bigger initial burst on page load
      if (!raf) raf = requestAnimationFrame(step);

      // Expose a function to trigger more confetti
      window.triggerConfetti = () => {
        let counter = 0;
        const streamInterval = setInterval(() => {
          spawn(20); // Spawn a small burst every 50ms
          if (!raf) raf = requestAnimationFrame(step);
          counter++;
          if (counter >= 20) clearInterval(streamInterval); // Stream for 1 second
        }, 50);
      };
    })();
  </script>
  <script>
    // On the final ranking page, trigger background stat calculation.
    document.addEventListener('DOMContentLoaded', () => {
      // Use a flag to ensure this only runs once per page load
      if (!window.statsCalculationStarted) {
        window.statsCalculationStarted = true;
        apiFetch('{{ url_for("api_calculate_game_stats") }}', { method: 'POST' })
          .catch(err => console.error("Background stat calculation failed:", err));
      }

      const statsBtnLink = document.querySelector('a[href="{{ url_for("stats") }}"]');
      if (statsBtnLink) {
        statsBtnLink.addEventListener('click', async (e) => {
          e.preventDefault(); // Stop immediate navigation
          const loadingOverlay = document.getElementById('loadingOverlay');
          
          // Function to check if stats are ready
          const checkStats = async () => {
            try {
              const res = await apiFetch('{{ url_for("api_game_stats_status") }}');
              return res.ready;
            } catch {
              return false;
            }
          };

          let isReady = await checkStats();
          if (!isReady) {
            if (loadingOverlay) loadingOverlay.classList.add('show');
            // Poll every 200ms until ready
            while (!isReady) {
              await new Promise(resolve => setTimeout(resolve, 200));
              isReady = await checkStats();
            }
            if (loadingOverlay) loadingOverlay.classList.remove('show');
          }
          window.location.href = statsBtnLink.href; // Navigate now that stats are ready
        });
      }
    });
  </script>
  {% endif %}

  <!-- =========================================================
       SCRIPT: GLOBAL SCROLL GUARD FOR iOS
       (blocks page rubber-band; only .container scrolls)
       ========================================================= -->
  <script>
    // Helper to check if any modal is active
    function isModalActive() {
      return !!document.querySelector('.modal-overlay.show');
    }
  </script>
  <script>
    (function(){
      const scrollArea = document.querySelector('.container'); // only scrollable region
      let startY = 0;
      let insideScrollable = false;

      function isInsideScrollable(el) {
        let n = el;
        while (n && n !== document.body) {
          if (n === scrollArea) return true;
          n = n.parentElement;
        }
        return false;
      }

      document.addEventListener('touchstart', (e) => {
        insideScrollable = isInsideScrollable(e.target);
        startY = (e.touches && e.touches.length) ? e.touches[0].clientY : 0;
      }, { passive: true });

      document.addEventListener('touchmove', (e) => {
        // If a modal is open, do not interfere with scrolling.
        if (isModalActive()) return;

        if (!scrollArea) { e.preventDefault(); return; }

        // If touch is outside the scroll area, block it outright.
        if (!insideScrollable) { e.preventDefault(); return; }

        // Inside scroll area: block rubber-band when at edges and trying to go past
        const y = (e.touches && e.touches.length) ? e.touches[0].clientY : startY;
        const dy = y - startY;

        const atTop = scrollArea.scrollTop <= 0;
        const atBottom = scrollArea.scrollTop + scrollArea.clientHeight >= scrollArea.scrollHeight - 1;

        if ((atTop && dy > 0) || (atBottom && dy < 0)) {
          e.preventDefault(); // stop bounce from reaching <body>
        }
      }, { passive: false });

      // Block wheel/trackpad page scroll (iPadOS / desktop Safari)
      document.addEventListener('wheel', (e) => {
        // If a modal is open, or if the event is inside the main scrollable area, do not interfere.
        if (isModalActive() || isInsideScrollable(e.target)) {
          return;
        }
        e.preventDefault();
      }, { passive: false });

      // Also hard-lock explicitly marked regions (e.g., bottom controls)
      document.querySelectorAll('[data-lock-scroll]').forEach(el=>{
        el.addEventListener('touchmove', e => e.preventDefault(), { passive:false });
        el.addEventListener('wheel',     e => e.preventDefault(), { passive:false });
      });
    })();
  </script>

  <!-- =========================================================
       SCRIPT: RAISE CONTROLS FOR IPHONE + SET CONTAINER BOTTOM INSET
       (fixed controls; only compute height; no extra spacer)
       ========================================================= -->
<script>
  (function(){
    const root = document.documentElement;
    const controls = document.querySelector('.controls');
    function setH(){ if (controls) root.style.setProperty('--controls-h', controls.getBoundingClientRect().height + 'px'); }
    window.addEventListener('load', setH, {once:true});
    window.addEventListener('resize', setH);
    window.addEventListener('orientationchange', setH);
    // iOS visual viewport changes
    if (window.visualViewport){
      visualViewport.addEventListener('resize', setH);
      visualViewport.addEventListener('scroll', setH);
    }
    document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) setH(); });
  })();
</script>

  <!-- =========================================================
       CONTROLS (BOTTOM BAR)
       ========================================================= -->
  {% if show_stats or show_leaderboard %}
    <div class="controls no-overscroll" data-lock-scroll>
      {% if show_leaderboard %}
        <div class="button-grid two" data-lock-scroll>
          <a href="{{ url_for('index') }}" onclick="popButton(this.querySelector('button'));" style="grid-column: 1;">
            <button type="button" class="export-btn main-action-btn">Back</button>
          </a>
          <button type="button" id="compareBtn" class="main-action-btn" onclick="popButton(this); toggleCompareMode();" style="background-color: #555; color: #fff;">Compare</button>
        </div>
      {% else %} {# This is for the show_stats page #}
        <div class="button-grid two" data-lock-scroll>
          <a href="{{ url_for('index') }}" onclick="popButton(this.querySelector('button'));"><button type="button" class="export-btn main-action-btn">Back</button></a>
          <form id="restartForm" action="{{ url_for('restart') }}" method="post">
            <button type="button" id="restartBtn" class="restart-btn main-action-btn">New Game</button>
          </form>
        </div>
      {% endif %}
    </div>
  {% elif game.phase == 'setup' %}
    <!-- Bottom controls for SETUP ‚Äî unified button-grid two -->
    <div class="controls no-overscroll" data-lock-scroll>
      <div class="button-grid setup-controls" data-lock-scroll>
        <button type="button" class="main-action-btn settings-icon-btn" aria-label="Settings" title="Settings" onclick="popButton(this); openSettings();">
          <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="currentColor"><path d="M19.43,12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49,1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46,2.18,14.25,2,14,2h-4c-.25,0-.46.18-.49.42l-.38,2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49,0-.61.22l-2,3.46c-.13.22-.07.49.12.64l2.11,1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11,1.65c-.19.15-.24.42-.12.64l2,3.46c.12.22.39.3.61.22l2.49-1c.52.4,1.08.73,1.69.98l.38,2.65c.03.24.24.42.49.42h4c.25,0,.46-.18.49-.42l.38-2.65c.61-.25,1.17-.59,1.69-.98l2.49,1c.23.09.49,0,.61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12,15.5c-1.93,0-3.5-1.57-3.5-3.5s1.57-3.5,3.5-3.5,3.5,1.57,3.5,3.5-1.57,3.5-3.5,3.5z"/></svg>
        </button>
        <a href="{{ url_for('leaderboard') }}" onclick="popButton(this.querySelector('button'));"><button type="button" class="settings-btn main-action-btn">Stats</button></a>
        <button type="submit" class="restart-btn main-action-btn" form="startForm" onclick="popButton(this);">Start Game</button>
      </div>
    </div>
  {% elif game.phase in ['playing','playoff'] %}
    <div class="controls no-overscroll" data-lock-scroll>
      <div class="button-grid" data-lock-scroll>
        <button type="button" class="score-btn minus" onclick="hit(-3, this)">-3</button>
        <button type="button" class="score-btn minus" onclick="hit(-2, this)">-2</button>
        <button type="button" class="score-btn minus" onclick="hit(-1, this)">-1</button>
        <button type="button" class="score-btn zero"  onclick="hit(0,  this)">0</button>
        <button type="button" class="score-btn plus"  onclick="hit(1,  this)">+1</button>
        <button type="button" class="score-btn plus"  onclick="hit(2,  this)">+2</button>
      </div>
      <div class="button-grid two playing" data-lock-scroll>
        <button type="button" id="undoBtn" class="undo-btn" onclick="popButton(this); undo();" {{ 'disabled' if game.phase == 'playoff' else '' }}>Undo</button>
        <button type="button" id="endBtn" class="end-btn" onclick="popButton(this); toggleEnd();">{{ 'Cancel' if game.end_after_round else 'End' }}</button>
      </div>
    </div>
  {% elif game.phase == 'final_ranking' %}
    <div class="controls no-overscroll" data-lock-scroll>
      <div class="button-grid final-controls" data-lock-scroll>
        <a href="{{ url_for('stats') }}" onclick="popButton(this.querySelector('button'));"><button type="button" class="export-btn main-action-btn">Stats</button></a>
        <button type="button" id="confettiBtn" class="confetti-btn" onclick="popButton(this); window.triggerConfetti();">üéâ</button>
        <form id="restartForm" action="{{ url_for('restart') }}" method="post">
          <button type="button" id="restartBtn" class="restart-btn main-action-btn">New Game</button>
        </form>
      </div>
    </div>
  {% endif %}

  <!-- Attach confirm to Start New Game -->
  <script>
    (function(){
      var btn = document.getElementById('restartBtn');
      var form = document.getElementById('restartForm');
      if (btn && form) {
        btn.addEventListener('click', async function(){
          popButton(this);
          const ok = await window.showConfirmModal({
            title: 'Start New Game',
            message: 'This will clear the current game and return to setup. Continue?',
            okText: 'Start New Game',
            cancelText: 'Cancel'
          });
          if (ok) form.submit();
        });
      }
    })();
  </script>

  <!-- =========================================================
       SCRIPT: SETTINGS MODAL LOGIC
       ========================================================= -->
  <script>
    const settingsOverlay = document.getElementById('settingsOverlay');
    const hapticsToggle   = document.getElementById('hapticsToggle');
    const holesInput      = document.getElementById('holesInput');
    const holesRow        = document.getElementById('holesSettingsRow');
    const rudenessSlider  = document.getElementById('rudenessSlider');
    const rudenessLabel   = document.getElementById('rudenessLabel');
    const settingsSummary = document.getElementById('settingsSummary');
    const clearRecentsBtn = document.getElementById('clearRecentsBtn');    
    const sidDisplay      = document.getElementById('sidDisplay');
    const uptimeDisplay   = document.getElementById('uptimeDisplay');

    // --- Custom Rudeness Slider Logic ---
    const RUDENESS_MAP = ['Serious', 'Medium', 'Rude'];
    const rudenessThumb = rudenessSlider.querySelector('.slider-thumb');
    let rudenessLevel = 0; // Internal state for the slider's value

    function setRudenessSlider(level, animate = false) {
      rudenessLevel = Math.max(0, Math.min(level, RUDENESS_MAP.length - 1));
      rudenessLabel.textContent = RUDENESS_MAP[rudenessLevel];
      // Position is 0% for level 0, 50% for level 1, 100% for level 2
      const percent = (rudenessLevel / (RUDENESS_MAP.length - 1)) * 100;
      if (!animate) rudenessThumb.classList.add('dragging'); // Prevent animation on initial set
      rudenessThumb.style.left = `${percent}%`;
      if (!animate) {
        // Force reflow and then remove the class to re-enable animation for future interactions
        rudenessThumb.offsetHeight; 
        rudenessThumb.classList.remove('dragging');
      }
    }

    function handleSliderMove(clientX) {
      const rect = rudenessSlider.getBoundingClientRect();
      const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
      
      // Update thumb position visually while dragging
      rudenessThumb.style.left = `${percent * 100}%`;

      // Update the label in real-time
      const level = Math.round(percent * (RUDENESS_MAP.length - 1));
      rudenessLabel.textContent = RUDENESS_MAP[level];
    }

    function handleSliderEnd(clientX) {
      const rect = rudenessSlider.getBoundingClientRect();
      const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
      const finalLevel = Math.round(percent * (RUDENESS_MAP.length - 1));
      setRudenessSlider(finalLevel, true); // Snap with animation
    }

    let isDragging = false;
    rudenessSlider.addEventListener('pointerdown', (e) => {
      isDragging = true;
      rudenessThumb.classList.add('dragging');
      rudenessSlider.setPointerCapture(e.pointerId);
      handleSliderMove(e.clientX);
    });
    rudenessSlider.addEventListener('pointermove', (e) => {
      if (!isDragging) return;
      handleSliderMove(e.clientX);
    });
    rudenessSlider.addEventListener('pointerup', (e) => {
      if (!isDragging) return;
      isDragging = false;
      rudenessThumb.classList.remove('dragging');
      rudenessSlider.releasePointerCapture(e.pointerId);
      handleSliderEnd(e.clientX);
    });
    // Also handle clicks on the track
    rudenessSlider.addEventListener('click', (e) => {
      // Prevent click from firing during a drag sequence
      if (e.target === rudenessThumb) return;
      handleSliderEnd(e.clientX);
    });

    // --- Uptime Clock Logic ---
    let uptimeInterval = null;
    function startUptimeClock(startTimeSeconds) {
      if (uptimeInterval) clearInterval(uptimeInterval);
      if (!startTimeSeconds) {
        uptimeDisplay.textContent = '';
        return;
      }

      const startTimeMs = startTimeSeconds * 1000;

      function update() {
        const now = Date.now();
        let totalSeconds = Math.floor((now - startTimeMs) / 1000);

        const days = Math.floor(totalSeconds / 86400);
        totalSeconds %= 86400;
        const hours = Math.floor(totalSeconds / 3600);
        totalSeconds %= 3600;
        const minutes = Math.floor(totalSeconds / 60);
        const seconds = totalSeconds % 60;

        let parts = [];
        if (days > 0) parts.push(`${days}d`);
        if (hours > 0) parts.push(`${hours}h`);
        if (minutes > 0) parts.push(`${minutes}m`);
        parts.push(`${seconds}s`);

        uptimeDisplay.innerHTML = `Uptime: <span style="color:#fff;">${parts.join(' ')}</span>`;
      }

      update(); // Initial call
      uptimeInterval = setInterval(update, 1000);
    }


    function openSettings(){
      const g = window.__gameCache;
      holesInput.value = g.holes || 20;
      setRudenessSlider(g.rudeness_level || 0);

      sidDisplay.innerHTML = `SID: <span style="color:#fff;">${g.sid || '...'}</span>`;
      startUptimeClock({{ app_start_time }});
      // Only show the holes/rounds setting during the setup phase
      if (g.phase === 'setup') {
        holesRow.style.display = 'grid';
        holesInput.disabled = false;
      } else {
        holesRow.style.display = 'none';
        holesInput.disabled = true;
      }

      updateSettingsSummary();
      if (typeof window.updateInstallVisibility === 'function') {
        window.updateInstallVisibility();
      }
      settingsOverlay.classList.add('show');
      document.body.style.overflow = 'hidden';
    }
    function updateSettingsSummary() {
      const g = window.__gameCache;
      const rudeness = RUDENESS_MAP[g.rudeness_level || 0];
      let summary = `${rudeness}`;
      if (g.phase === 'setup') {
        summary += `, ${holesInput.value} rounds`;
      } else {
        summary += `, ${g.holes} rounds`;
      }
      settingsSummary.textContent = summary;
    }
    function closeSettings(){

      if (uptimeInterval) clearInterval(uptimeInterval);
      settingsOverlay.classList.remove('show');
      document.body.style.overflow = '';
    }
    async function saveSettings(){
      const payload = {};

      payload.rudeness_level = rudenessLevel;
      const g = window.__gameCache;
      if (g.phase === 'setup') {
        const newHoles = parseInt(holesInput.value, 10);
        if (newHoles && newHoles !== g.holes) {
          payload.holes = newHoles;
        }
      }

      try {
        const data = await apiFetch('{{ url_for("api_settings") }}', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload) });
        if (data.ok && data.game) {
          window.__gameCache = data.game;
          if (typeof saveLocal === 'function') saveLocal(data.game);
          if (data.app_start_time) startUptimeClock(data.app_start_time);
          updateSettingsSummary();
        }
        showToast('Settings saved', 'success');
      } catch(e) { showToast('Could not save settings', 'error'); }
    }

    clearRecentsBtn.addEventListener('click', async () => {
      const ok = await window.showConfirmModal({
        title: 'Clear Recent Players',
        message: 'Are you sure you want to remove all recent player names? This cannot be undone.',
        okText: 'Clear',
        cancelText: 'Cancel'
      });
      if (!ok) return;

      try {
        const data = await apiFetch('{{ url_for("api_clear_recents") }}', { method: 'POST' });
        if (data.ok && data.game) {
          window.__gameCache = data.game;
          // Update the correct local variable before re-rendering
          allRecentNames = data.game.recent_names || [];
          if (typeof saveLocal === 'function') saveLocal(data.game);
          showToast('Recent players cleared', 'success');
          // Re-render the recent players list on the setup screen if it exists
          if (typeof renderRecent === 'function') {
            renderRecent();
          }
        }
      } catch (e) { showToast('Could not clear recent players', 'error'); }
    });

    // --- Clear Cache & Refresh Logic ---
    const clearCacheBtn = document.getElementById('clearCacheBtn');
    clearCacheBtn.addEventListener('click', async () => {
      const ok = await window.showConfirmModal({
        title: 'Clear Cache & Refresh',
        message: 'This will log you out of the current game, unregister the service worker, and force a full refresh. Are you sure?',
        okText: 'Clear & Refresh',
        cancelText: 'Cancel'
      });
      if (!ok) return;

      try {
        // 1. Unregister service workers
        const registrations = await navigator.serviceWorker.getRegistrations();
        for (const registration of registrations) { await registration.unregister(); }
        // 2. Clear all Cache Storage
        const keys = await caches.keys();
        await Promise.all(keys.map(key => caches.delete(key)));
        // 3. Clear local storage backup and navigate to the logout route to clear the session
        localStorage.clear();
        window.location.href = '{{ url_for("logout") }}';
      } catch (e) { showToast('Failed to clear cache.', 'error'); console.error(e); }
    });
  </script>
  
  <!-- New script for Player Stats Modal -->
  <script>
    const playerStatsOverlay = document.getElementById('playerStatsOverlay');
    const playerStatsTitle = document.getElementById('playerStatsTitle');
    const playerStatsContent = document.getElementById('playerStatsContent');
    const allPlayersModalContent = document.getElementById('allPlayersContent'); // Assuming this will be added

    async function openPlayerStats(playerName, showDeltas = false) {
      playerStatsTitle.textContent = `${playerName}'s Stats`;
      playerStatsContent.innerHTML = '<div class="stat-block" style="grid-column: 1 / -1; text-align: center;">Loading...</div>';
      playerStatsOverlay.classList.add('show');
      document.body.style.overflow = 'hidden';
      
      try {
        const data = await apiFetch(`/api/player/${encodeURIComponent(playerName)}`);
        if (!data.ok) throw new Error(data.error || 'Could not load stats');

        const stats = data.stats;
        const deltas = stats.last_game_deltas || {};

        function getDeltaHtml(deltaValue) {
          if (!deltaValue || !showDeltas) return '';
          const isGood = deltaValue > 0;
          return `<div class="stat-delta ${isGood ? 'good' : 'bad'}">
            ${isGood ? '‚ñ≤' : '‚ñº'} ${deltaValue}
          </span>`;
        }

        // For average score, lower is better
        function getAvgDeltaHtml(deltaValue) {
          if (!deltaValue || !showDeltas) return '';
          const isGood = deltaValue < 0;
          return `<div class="stat-delta ${isGood ? 'good' : 'bad'}">
            ${isGood ? '‚ñº' : '‚ñ≤'} ${deltaValue.toFixed(2)}
          </span>`;
        }

        function getPercDeltaHtml(deltaValue) {
          if (!deltaValue || !showDeltas) return '';
          const isGood = deltaValue > 0;
          return `<div class="stat-delta ${isGood ? 'good' : 'bad'}">
            ${isGood ? '‚ñ≤' : '‚ñº'} ${Math.round(deltaValue)}%
          </span>`;
        }
        
        // For best/worst score, lower is better
        function getGameScoreDeltaHtml(deltaValue) {
          if (!deltaValue || !showDeltas) return '';
          const isGood = deltaValue < 0; // A new best score is a negative delta
          return `<div class="stat-delta ${isGood ? 'good' : 'bad'}">
            ${isGood ? '‚ñº' : '‚ñ≤'} ${deltaValue}
          </span>`;
        }

        function formatScoreWithSign(score) {
            if (score > 0) return `+${score}`;
            return String(score || 0);
        }

        playerStatsContent.innerHTML = `
          <div class="stat-block">
            <ol>
              <li><div class="stat-left"><span class="stat-player">üé≤ Games Played</span></div><div class="stat-right"><span>${stats.games_played || 0}</span> ${getDeltaHtml(deltas.games_played)}</div></li>
              <li><div class="stat-left"><span class="stat-player">üèÜ Wins</span></div><div class="stat-right"><span>${stats.wins || 0}</span> ${getDeltaHtml(deltas.wins)}</div></li>
              <li><div class="stat-left"><span class="stat-player">üìà Win Rate</span></div><div class="stat-right"><span>${Math.round(stats.win_percentage)}%</span> ${getPercDeltaHtml(deltas.win_percentage_delta)}</div></li>
              <li><div class="stat-left"><span class="stat-player">üìä Average Score</span></div><div class="stat-right"><span>${stats.average_score.toFixed(2)}</span> ${getAvgDeltaHtml(deltas.average_score_delta)}</div></li>
              <li><div class="stat-left"><span class="stat-player">üéØ On Target %</span></div><div class="stat-right"><span>${Math.round(stats.on_target_percentage)}%</span> ${getPercDeltaHtml(deltas.on_target_percentage_delta)}</div></li>
              <li><div class="stat-left"><span class="stat-player">‚≠ê Best Game</span></div><div class="stat-right"><span>${formatScoreWithSign(stats.best_game_score)}</span> ${getGameScoreDeltaHtml(deltas.best_game_score_delta)}</div></li>
              <li><div class="stat-left"><span class="stat-player">üíÄ Worst Game</span></div><div class="stat-right"><span>${formatScoreWithSign(stats.worst_game_score)}</span> ${getGameScoreDeltaHtml(deltas.worst_game_score_delta)}</div></li>
              <li><div class="stat-left"><span class="stat-player">üïäÔ∏è Total Birdies</span></div><div class="stat-right"><span>${stats.total_birdies || 0}</span> ${getDeltaHtml(deltas.total_birdies)}</div></li>
              <li style="border-bottom: none;"><div class="stat-left"><span class="stat-player">üíî Total Bogeys</span></div><div class="stat-right"><span>${stats.total_bogeys || 0}</span> ${getDeltaHtml(deltas.total_bogeys)}</div></li>
            </ol>
          </div>
        `;
      } catch (e) {
        playerStatsContent.innerHTML = `<div class="stat-block" style="grid-column: 1 / -1; text-align: center; color: #ffcccc;">${e.message}</div>`;
      }
    }

    function closePlayerStats() {
      playerStatsOverlay.classList.remove('show');
      document.body.style.overflow = '';
    }
  </script>
  <!-- New script for Player Comparison Modal -->
  <script>
    const compareOverlay = document.getElementById('playerCompareOverlay');
    const compareSelect1 = document.getElementById('comparePlayer1');
    const compareSelect2 = document.getElementById('comparePlayer2');
    const comparisonResult = document.getElementById('comparisonResult');
    const compareBtn = document.getElementById('compareBtn');
    let isCompareModeActive = false;
    let comparisonSelection = [];

    function closePlayerCompareModal() {
      compareOverlay.classList.remove('show');
      // Exit compare mode (which handles clearing highlights) after a delay.
      setTimeout(exitCompareMode, 100);
    }

    function enterCompareMode() {
      isCompareModeActive = true;
      compareBtn.textContent = 'Cancel';
      compareBtn.style.backgroundColor = '#E3292E'; // Red for cancel
      showToast('Select two players from the list to compare.', 'info', 3000);
    }

    function exitCompareMode() {
      isCompareModeActive = false;
      compareBtn.textContent = 'Compare';
      compareBtn.style.backgroundColor = '#555';
      comparisonSelection = [];
      document.querySelectorAll('#leaderboardList li.selected-for-compare').forEach(el => el.classList.remove('selected-for-compare'));
    }

    function toggleCompareMode() {
      if (isCompareModeActive) {
        exitCompareMode();
      } else {
        enterCompareMode();
      }
    }

    async function showComparisonFor(name1, name2) {
      if (!name1 || !name2) {
        return;
      }
      compareOverlay.classList.add('show');
      comparisonResult.innerHTML = '<div style="text-align: center;">Loading comparison...</div>';

      try {
        const [data1, data2] = await Promise.all([
          apiFetch(`/api/player/${encodeURIComponent(name1)}`),
          apiFetch(`/api/player/${encodeURIComponent(name2)}`)
        ]);

        if (!data1.ok || !data2.ok) throw new Error('Could not load stats for one or more players.');

        renderComparison(data1.stats, data2.stats, name1, name2);
      } catch (e) {
        comparisonResult.innerHTML = `<div style="color: #ffcccc;">${e.message}</div>`;
      }
    }

    function renderComparison(stats1, stats2, name1, name2) {
      const getDelta = (val1, val2, lowerIsBetter = false) => {
        if (val1 === val2) return '';
        const isGood = lowerIsBetter ? val2 < val1 : val2 > val1;
        return `<span class="delta ${isGood ? 'good' : 'bad'}">${isGood ? '‚ñ≤' : '‚ñº'}</span>`;
      };

      const statsToCompare = [
        { name: 'üé≤ Games Played', key: 'games_played', format: v => v || 0 },
        { name: 'üèÜ Wins', key: 'wins', format: v => v || 0 },
        { name: 'üìà Win Rate', key: 'win_percentage', format: v => `${Math.round(v)}%` },
        { name: 'üìä Average Score', key: 'average_score', format: v => v.toFixed(2), lowerIsBetter: true },
        { name: 'üéØ On Target %', key: 'on_target_percentage', format: v => `${Math.round(v)}%` },
        { name: '‚≠ê Best Game', key: 'best_game_score', format: v => (v > 0 ? `+${v}` : String(v || 0)), lowerIsBetter: true },
        { name: 'üíÄ Worst Game', key: 'worst_game_score', format: v => (v > 0 ? `+${v}` : String(v || 0)), lowerIsBetter: true },
        { name: 'üïäÔ∏è Total Birdies', key: 'total_birdies', format: v => v || 0 },
        { name: 'üíî Total Bogeys', key: 'total_bogeys', format: v => v || 0, lowerIsBetter: true },
      ];

      const rowsHtml = statsToCompare.map(stat => {
        const val1 = stats1[stat.key] || 0;
        const val2 = stats2[stat.key] || 0;
        return `
          <tr>
            <td class="stat-name">${stat.name}</td>
            <td>${stat.format(val1)} ${getDelta(val2, val1, stat.lowerIsBetter)}</td>
            <td>${stat.format(val2)} ${getDelta(val1, val2, stat.lowerIsBetter)}</td>
          </tr>
        `;
      }).join('');

      comparisonResult.innerHTML = `
        <table class="comparison-results-table">
          <thead><tr><th>Stat</th><th>${escapeHtml(name1)}</th><th>${escapeHtml(name2)}</th></tr></thead>
          <tbody>${rowsHtml}</tbody>
        </table>
      `;
    }

    // Delegated click listener for leaderboard and stats pages
    document.querySelector('.container').addEventListener('click', (e) => {
      const link = e.target.closest('a.stat-player-link');
      if (!link) return;
      
      const playerName = link.parentElement.dataset.playerName;
      if (!playerName) return;

      if (isCompareModeActive) {
        const listItem = link.closest('li');
        const isSelected = listItem.classList.contains('selected-for-compare');

        if (isSelected) {
          // Deselect
          listItem.classList.remove('selected-for-compare');
          comparisonSelection = comparisonSelection.filter(p => p !== playerName);
        } else {
          // Select
          if (comparisonSelection.length < 2) {
            listItem.classList.add('selected-for-compare');
            comparisonSelection.push(playerName);
          }
        }

        if (comparisonSelection.length === 2) {
          showComparisonFor(comparisonSelection[0], comparisonSelection[1]);
        }
      } else {
        // Default behavior: open player stats
        const showDeltas = link.closest('.stat-block') && !link.closest('#leaderboardList');
        openPlayerStats(playerName, showDeltas);
      }
    });
  </script>

  {% if show_stats %}
  <!-- =========================================================
       SCRIPT: STATS BAR CHART ANIMATION
       ========================================================= -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const observer = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const bar = entry.target;
            const targetWidth = bar.getAttribute('data-width');
            bar.style.setProperty('--target-width', targetWidth || '0px');
            bar.offsetWidth; // Force reflow to ensure initial width:0 is rendered
            bar.classList.add('visible');
            obs.unobserve(bar); // Animate only once
          }
        });
      }, { threshold: 0.1 }); // Trigger when 10% of the bar is visible

      const statBars = document.querySelectorAll('.stat-bar');
      if (statBars.length > 0) {
        statBars.forEach(bar => observer.observe(bar));
      }
    });
  </script>
  {% elif show_leaderboard %}
  <!-- =========================================================
       SCRIPT: LEADERBOARD SEARCH
       ========================================================= -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const searchInput = document.getElementById('leaderboardSearch');
      const leaderboardList = document.getElementById('leaderboardList');
      if (!searchInput || !leaderboardList) return;

      searchInput.addEventListener('input', () => {
        const searchTerm = searchInput.value.toLowerCase();
        const players = leaderboardList.querySelectorAll('li');
        players.forEach(player => {
          const name = player.dataset.leaderboardName || '';
          if (name.includes(searchTerm)) {
            player.style.display = '';
          } else {
            player.style.display = 'none';
          }
        });
      });
    });
  </script>
  <script>
    async function deletePlayerStats(playerName, buttonElement) {
      const ok = await window.showConfirmModal({
        title: 'Delete Player Stats',
        message: `Are you sure you want to permanently delete all stats for "${playerName}"? This cannot be undone.`,
        okText: 'Delete',
        cancelText: 'Cancel'
      });

      if (!ok) return;

      try {
        const data = await apiFetch(`/api/player/${encodeURIComponent(playerName)}`, { method: 'DELETE' });
        if (data.ok) {
          showToast(`Stats for ${playerName} have been deleted.`, 'success');
          // Remove the list item from the DOM
          buttonElement.closest('li').remove();
        } else {
          throw new Error(data.error || 'Server rejected the request.');
        }
      } catch (e) {
        showToast(`Error: ${e.message}`, 'error');
      }
    }
  </script>
  {% endif %}

  <!-- =========================================================
       SCRIPT: AUTO-HIDE FLASH MESSAGES (RUNS LAST)
       ========================================================= -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const flashMessages = document.querySelectorAll('.flash');
      flashMessages.forEach(flash => {
        setTimeout(() => {
          flash.classList.add('hiding');
          // After the animation, remove the element from the DOM
          flash.addEventListener('transitionend', () => flash.remove(), { once: true });
        }, 3000); // 3 seconds
      });
    });
  </script>
  <!-- =========================================================
       SCRIPT: INITIAL PRELOADER
       ========================================================= -->
  <script>
    // Define a global cache for all players
    window.__allPlayersCache = [];

    document.addEventListener('DOMContentLoaded', async () => {
      const loadingOverlay = document.getElementById('initialLoadingOverlay');

      const hideLoader = () => {
        if (loadingOverlay) {
          loadingOverlay.classList.add('hidden');
          loadingOverlay.addEventListener('transitionend', () => loadingOverlay.remove(), { once: true });
        }
      };

      try {
        // Preload all player data
        const data = await apiFetch('{{ url_for("get_all_players") }}');
        if (data.ok && data.players) {
          window.__allPlayersCache = data.players;
        } else {
          throw new Error('Failed to preload player data.');
        }
      } catch (error) {
        console.error('Preloading failed:', error);
      } finally {
        // Always hide the loader, even if preloading fails
        hideLoader();
      }
    });
  </script>
  <!-- =========================================================
       SCRIPT: PRELOADED CONFETTI LOGIC
       ========================================================= -->
  <script>
    (function(){
      const canvas = document.getElementById('confettiCanvas');
      if (!canvas) return;
      const ctx = canvas.getContext('2d');
      let W, H, raf = null;
      let pieces = [];

      function resize(){ W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
      window.addEventListener('resize', resize);
      resize(); // Initial size

      function spawn(n){
        for(let i=0;i<n;i++){
          pieces.push({
            x: Math.random() * W, y: -20 - Math.random() * 20,
            vx: (Math.random()-0.5)*1, vy: 2+Math.random()*3,
            size: 5+Math.random()*8, rot: Math.random()*Math.PI, vr: (Math.random()-0.5)*0.2,
            shape: Math.random()<0.5?'rect':'tri',
            life: 2.0,
            fade: 0.002 + Math.random() * 0.005
          });
        }
      }

      function step(){
        ctx.clearRect(0,0,W,H);
        let i = pieces.length;
        while (i--) {
          const p = pieces[i];
          p.life -= p.fade;
          if (p.life <= 0) { pieces.splice(i, 1); continue; }
          p.vy += 0.02; p.x += p.vx; p.y += p.vy; p.rot += p.vr;
          ctx.save();
          ctx.globalAlpha = p.life;
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = ['#E3292E','#309F6A','#F9DFBC','#ffffff','#ffd54f'][Math.floor(Math.random()*5)];
          if (p.shape==='rect'){ ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6); }
          else { ctx.beginPath(); ctx.moveTo(0,-p.size/2); ctx.lineTo(p.size/2,p.size/2); ctx.lineTo(-p.size/2,p.size/2); ctx.closePath(); ctx.fill(); }
          ctx.restore();
        }
        if (pieces.length > 0) { raf = requestAnimationFrame(step); }
        else { ctx.clearRect(0,0,W,H); cancelAnimationFrame(raf); raf = null; }
      }

      window.initWinnerConfetti = () => {
        const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        if (prefersReduced) return;
        spawn(300);
        if (!raf) raf = requestAnimationFrame(step);
      };

      window.triggerConfetti = () => {
        // Add another burst of confetti to the screen
        spawn(150);
        if (!raf) raf = requestAnimationFrame(step);
      };
    })();
  </script>
</body>
</html>