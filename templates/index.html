<!DOCTYPE html>
<html lang="en">
<head>
  <!-- =========================================================
       PAGE META / PWA BASICS
       ========================================================= -->
  <meta charset="UTF-8">
  <!-- Prevent auto zoom on mobile + enable iOS safe areas -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Darts Golf Scorer</title>

  <!-- Manifest + theme-color for PWA -->
  <link rel="manifest" href="{{ url_for('static', filename='manifest.webmanifest') }}">
  <meta name="theme-color" content="#182634">

  <!-- iOS/Android standalone capability -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Darts Golf">
  <meta name="mobile-web-app-capable" content="yes">


  <!-- Service Worker registration -->
  <script>
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', () => navigator.serviceWorker.register('/sw.js').catch(()=>{}));
    }
  </script>

  <!-- Favicons / Touch icons -->
  <link rel="icon" href="{{ url_for('static', filename='icons/dartboard.svg') }}" type="image/svg+xml">
  <link rel="icon" type="image/png" sizes="32x32" href="{{ url_for('static', filename='icons/dartboard-32.png') }}">
  <link rel="icon" type="image/png" sizes="192x192" href="{{ url_for('static', filename='icons/dartboard-192.png') }}">
  <link rel="apple-touch-icon" sizes="180x180" href="{{ url_for('static', filename='icons/dartboard-180.png') }}">
  <link rel="shortcut icon" href="{{ url_for('static', filename='favicon.ico') }}">

  <!-- Google Font for the main title -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Rye&family=Galada&display=swap" rel="stylesheet">

  <!-- =========================================================
       GLOBAL STYLES (CSS) - Externalized
       ========================================================= -->
  <link rel="stylesheet" href="{{ url_for('static', filename='style.css', v=app_start_time) }}">
</head>

<body>
  <!-- =========================================================
       GLOBAL CANVAS FOR CONFETTI
       ========================================================= -->
  <canvas id="confettiCanvas"></canvas>

  <!-- =========================================================
       MAIN CONTENT CONTAINER
       ========================================================= -->
  <div class="container">
    <!-- Flash message container (moved to global scope) -->
    <div class="flash-container">
      {% with messages = get_flashed_messages(with_categories=true) %}
        {% if messages %}
          {% for category, msg in messages %}
            <div class="flash {{ category or 'info' }}" role="alert">{{ msg }}</div>
          {% endfor %}
        {% endif %}
      {% endwith %}
    </div>
    {% if show_stats %}
      <!-- =====================================================
           STATS VIEW
           ===================================================== -->
      <h1>Game Stats</h1>


      <div class="stat-block">
        <div class="stat-title">‚õ≥ Birdie Streaks</div>
        <small class="stat-description">Longest consecutive run of rounds with a score below par.</small>
        {% if birdie_streak_ranking %}
          <ol>
            {% for row in birdie_streak_ranking %}
              <li>
                <div class="stat-left">
                  <span class="stat-player">{{ row.name }}</span>
                </div>
                <div class="stat-right">
                  <span>{{ row.streak }}</span>
                  <div class="stat-bar" data-width="{{ ((row.streak / (max_birdie_streak or 1) * 60) | round(0)) or (2 if row.streak > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>

      <div class="stat-block">
        <div class="stat-title">üî• Bogey Streaks</div>
        <small class="stat-description">Longest consecutive run of rounds with a score above par.</small>
        {% if bogey_streak_ranking %}
          <ol>
            {% for row in bogey_streak_ranking %}
              <li>
                <div class="stat-left">
                  <span class="stat-player">{{ row.name }}</span>
                </div>
                <div class="stat-right">
                  <span>{{ row.streak }}</span>
                  <div class="stat-bar bad" data-width="{{ ((row.streak / (max_bogey_streak or 1) * 60) | round(0)) or (2 if row.streak > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>

      <div class="stat-block">
        <div class="stat-title">üïäÔ∏è Total Birdies</div>
        <small class="stat-description">Total number of rounds with a score below par.</small>
        {% if most_birdies_ranking %}
          <ol>
            {% for row in most_birdies_ranking %}
              <li>
                <div class="stat-left">
                  <span class="stat-player">{{ row.name }}</span>
                </div>
                <div class="stat-right">
                  <span>{{ row.count }}</span>
                  <div class="stat-bar" data-width="{{ ((row.count / (max_birdie_count or 1) * 60) | round(0)) or (2 if row.count > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>
  
      <div class="stat-block">
        <div class="stat-title">üíî Total Bogeys</div>
        <small class="stat-description">Total number of rounds with a score above par.</small>
        {% if most_bogeys_ranking %}
          <ol>
            {% for row in most_bogeys_ranking %}
              <li>
                <div class="stat-left">
                  <span class="stat-player">{{ row.name }}</span>
                </div>
                <div class="stat-right">
                  <span>{{ row.count }}</span>
                  <div class="stat-bar bad" data-width="{{ ((row.count / (max_bogey_count or 1) * 60) | round(0)) or (2 if row.count > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>      

      <div class="stat-block">
        <div class="stat-title">üéØ On Target %</div>
        <small class="stat-description">Percentage of rounds completed at par or better.</small>
        {% if on_target_ranking %}
          <ol>
            {% for row in on_target_ranking %}
              <li>
                <div class="stat-left">
                  <span class="stat-player">{{ row.name }}</span>
                </div>
                <div class="stat-right">
                  <span>{{ row.percentage | round | int }}%</span>
                  <div class="stat-bar" data-width="{{ ((row.percentage / (max_on_target_percentage or 1) * 60) | round(0)) or (2 if row.percentage > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>


      
      <div class="stat-block"> {# Fixed stray char #}
        <div class="stat-title">üìä Average Scores</div>
        <small class="stat-description">Average score per round over the entire game.</small>
        {% if average_ranking %}
          <ol>
            {% for row in average_ranking %}
              <li>
                <div class="stat-left">
                  <span class="stat-player">{{ row.name }}</span>
                  <small class="stat-sub">(over {{ row.rounds }} rounds)</small>
                </div>
                <div class="stat-right">
                  <span>{{ "%+.2f"|format(row.average) }}</span>
                  <div class="stat-bar {{ 'bad' if row.average > 0 else ('neutral' if row.average == 0 else '') }}" data-width="{{ ((row.average|abs / (max_average_abs or 1) * 60) | round(0)) or (2 if row.average|abs > 0 else 0) }}px">
                  </div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No completed rounds yet.</small>
        {% endif %}
      </div>

      <div class="stat-block">
        <div class="stat-title">üìà Biggest Saves</div>
        <small class="stat-description">Largest score improvement in the game.</small>
        {% if comeback_ranking %}
          <ol>
            {% for cb in comeback_ranking %}
              <li>
                <div class="stat-left">
                  <span class="stat-player">{{ cb.player }}</span>
                  <small class="stat-sub">
                    from {{ "%+d"|format(cb.from_score) }} on Round {{ cb.from_round }}
                    to {{ "%+d"|format(cb.to_score) }} on Round {{ cb.to_round }}
                  </small>
                </div>
                <div class="stat-right">
                  <span>{{ cb.improvement }} saved</span>
                  <div class="stat-bar" data-width="{{ ((cb.improvement / (max_comeback_improvement or 1) * 60) | round(0)) or (2 if cb.improvement > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No positive improvements detected.</small>
        {% endif %}
      </div>

      <div class="stat-block">
        <div class="stat-title">üìâ Worst Falls</div>
        <small class="stat-description">Largest score drop in the game.</small>
        {% if fall_ranking %}
          <ol>
            {% for fall in fall_ranking %}
              <li>
                <div class="stat-left">
                  <span class="stat-player">{{ fall.player }}</span>
                  <small class="stat-sub">
                    from {{ "%+d"|format(fall.from_score) }} on Round {{ fall.from_round }}
                    to {{ "%+d"|format(fall.to_score) }} on Round {{ fall.to_round }}
                  </small>
                </div>
                <div class="stat-right">
                  <span>{{ fall.worsening }} lost</span>
                  <div class="stat-bar bad" data-width="{{ ((fall.worsening / (max_fall_worsening or 1) * 60) | round(0)) or (2 if fall.worsening > 0 else 0) }}px"></div>
                </div>
              </li>
            {% endfor %}
          </ol>
        {% else %}
          <div class="stat-value">‚Äî</div>
          <small>No score worsening detected.</small>
        {% endif %}
      </div>

    {% else %}
      <!-- =====================================================
           NORMAL GAME VIEWS
           ===================================================== -->

      {% if game.phase == 'setup' %}
        <!-- =========================
             SETUP PHASE
             ========================= -->
        <div class="setup-screen">
          <h1 class="main-title">
            <span class="title-main">DARTS GOLF</span>
            <span class="title-sub">Scorer</span>
          </h1>

          <!-- Add-one-name-at-a-time input -->
          <form id="startForm" action="{{ url_for('start_game') }}" method="post" style="margin-top:12px;">
            <input id="playersInput" type="hidden" name="players" required>

            <div class="name-input-wrap" style="position:relative; display:flex; gap:8px; align-items:center; margin-top:8px;">
              <input
                id="nameField"
                type="text"
                placeholder="Type a player name"
                aria-label="Player name"
                class="settings-input"
                style="flex:1; padding-right:56px; padding-top: 12px; padding-bottom: 12px; box-sizing: border-box;"
                autocomplete="off"
                inputmode="text"
                maxlength="14"
              >
              <button
                type="button"
                id="addNameBtn"
                class="settings-btn"
                aria-label="Add player"
                title="Add player"
                style="position:absolute; right:6px; top:50%; transform:translateY(-50%); padding:8px 12px;"
              >‚ûú</button>
            </div>
            <small style="display:block; color:#bbb; margin-top:6px;">
              Press <b>Enter</b> or tap the arrow to add. Tap <b>‚úï</b> to remove. Drag pills to reorder.
            </small>

          </form>

          <!-- New two-column container for player lists -->
          <div class="player-lists-container">
            <!-- Left Column: Selected Players -->
            <div class="player-list-wrap" id="selectedWrap">
              <div class="player-list-title">Players (drag to reorder)</div>
              <div id="selectedChipList" class="chip-list"></div>
            </div>
            <!-- Right Column: Recent Players -->
            <div class="player-list-wrap" id="recentWrap">
              <div class="player-list-title">Recent players</div>
              <div id="chipList" class="chip-list"></div>
            </div>
          </div>

        </div>

      {% elif game.phase == 'playing' %}
        <!-- =========================
             PLAYING PHASE
             ========================= -->
        <div class="info-bar" id="info-bar" aria-live="polite" role="status">
          <div class="round-count">
            <span class="round-label">ROUND</span>
            <span class="round-number-wrapper">
              <span class="round-number-digit old-digit" style="transform: translateY(0); opacity: 1;">{{ "%02d"|format(game.current_round) }}</span>
              <span class="round-number-digit new-digit" style="transform: translateY(100%); opacity: 0;"></span>
            </span>
            <span class="round-total">/ {{ game.holes }}</span>
          </div>
          <div class="turn-info">{{ game.players[game.current_player_index] }}'s Turn</div>

          {% if game.end_after_round %}
            <div class="end-banner-wrap">
              <div class="end-banner">
                Game will end after this round. Finish all players this round to finalize and run tie-breakers.
              </div>
            </div>
          {% endif %}
        </div>

        <table class="scoreboard playing" id="scoreboard">
          <thead>
            <tr><th scope="col">&nbsp;</th>
              {% for p in game.players %}
                {% set is_cur = (p == game.players[game.current_player_index]) %}
                <th scope="col" class="{{ 'current-player-header' if is_cur else '' }}">
                  {% if game.players|length > 4 %}
                    {{ p.split(' ')|map('first')|join('')|upper }}
                  {% else %}
                    {{ p }}
                  {% endif %}
                </th>
              {% endfor %}
            </tr>
          </thead>
          <tbody>
            <tbody>
  <tr class="total-row"><th>Total</th>
    {% for p in game.players %}
      {% set s = game.scores.get(p, 0) %} {# This is a data cell, not a header #}
      <td>{% if s > 0 %}+{% endif %}{{ s }}</td>
    {% endfor %}
  </tr>

  <!-- ‚úÖ Current round being played -->
  <tr class="current-row"><th>{{ "%02d"|format(game.current_round) }}</th>
    {% for p in game.players %}
      {% set v = game.round_history[game.current_round - 1].get(p) %} {# This is a data cell, not a header #}
      {% set is_cur_cell = (loop.index0 == game.current_player_index) %}
      {% if v is not none %}
        {% set ns = namespace(total=0) %}
        {% for r in range(game.current_round) %}
          {% set ns.total = ns.total + (game.round_history[r].get(p, 0)) %}
        {% endfor %}
        <td>
          <div class="cell">
            <span class="total-pill">{{ ns.total > 0 and '+' or '' }}{{ ns.total }}</span>
            <span class="delta-corner {{ 'pos' if v > 0 else ('neg' if v < 0 else 'zero') }}">
              {{ v > 0 and '+' or '' }}{{ v }}
            </span>
          </div>
        </td>
      {% else %}
        <td class="{{ 'current-player-cell' if is_cur_cell else '' }}">
          <div class="cell">
            <span class="total-pill">0</span>
            <span class="delta-corner hidden">0</span>
          </div>
        </td>
      {% endif %}
    {% endfor %}
  </tr>

  <!-- üîÅ Previous rounds (from latest to earliest) -->
  {% for i in range(game.current_round - 1) | reverse %}
    <tr><th>{{ "%02d"|format(i + 1) }}</th>
      {% for p in game.players %} {# This is a data cell, not a header #}
        {% set v = game.round_history[i].get(p) %}
        {% if v is not none %}
          {% set ns = namespace(total=0) %}
          {% for r in range(i + 1) %}
            {% set ns.total = ns.total + (game.round_history[r].get(p, 0)) %}
          {% endfor %}
          <td>
            <div class="cell">
              <span class="total-pill">{{ ns.total > 0 and '+' or '' }}{{ ns.total }}</span>
              <span class="delta-corner {{ 'pos' if v > 0 else ('neg' if v < 0 else 'zero') }}">
                {{ v > 0 and '+' or '' }}{{ v }}
              </span>
            </div>
          </td>
        {% else %}
          <td></td>
        {% endif %}
      {% endfor %}
    </tr>
  {% endfor %}
</tbody>

        </table>

      {% elif game.phase == 'playoff' %}
        <!-- =========================
             PLAYOFF (TIE-BREAKER) PHASE
             ========================= -->
        <div class="info-bar" id="info-bar" aria-live="polite" role="status">
          <div class="round-count">
            <span class="round-label">TIE-BREAKER</span>
            <span class="round-number-digit old-digit" style="transform: translateY(0); opacity: 1;">{{ "%02d"|format(game.playoff_round) }}</span>
            <span class="round-number-digit new-digit" style="transform: translateY(100%); opacity: 0;"></span>
            </span>
          </div>
          <div class="turn-info">
            {% if game.playoff_group %}{{ game.playoff_group[game.current_player_index] }}'s Turn{% endif %}
          </div>
        </div>
                <table class="scoreboard" id="scoreboard">
          {# -----------------------------------------------------
             BUILD A STABLE COLUMN SET (ALL PLAYERS IN THIS TIE)
             ----------------------------------------------------- #}
          {% set tie_players = game.playoff_pool %}

          <thead>
            <tr><th scope="col">&nbsp;</th>
              {% for p in tie_players %}
                {# highlight only if this header is the current shooter #}
                {% set is_cur = (game.playoff_group and p == game.playoff_group[game.current_player_index]) %}
                <th scope="col" class="{{ 'current-player-header' if is_cur else '' }}" data-player-name="{{ p }}">
                  {% if tie_players|length > 4 %}
                    {{ p.split(' ')|map('first')|join('')|upper }}
                  {% else %}
                    {{ p }}
                  {% endif %}
                </th>
              {% endfor %}
            </tr>
          </thead>

          <tbody>
            <!-- Stable total row: base score repeated across all tie players -->
            <tr class="total-row">
              <th scope="row">Total</th>
              {% for _ in tie_players %}
                {% set s = game.playoff_base_score %}
                <td>{% if s > 0 %}+{% endif %}{{ s }}</td>
              {% endfor %}
            </tr>

            <!-- ‚úÖ Current TB round being played (use stable columns) -->
            <tr class="current-row">
              <th scope="row">TB {{ "%02d"|format(game.playoff_round) }}</th>
              {% for p in tie_players %}
                {% set v = game.playoff_round_scores.get(p) %}
                {% set is_current = (game.playoff_group and p == game.playoff_group[game.current_player_index]) %}
                {% if v is not none %}
                  <td>
                    <div class="cell">
                      <span class="total-pill">{{ v > 0 and '+' or '' }}{{ v }}</span>
                      <span class="delta-corner {{ 'pos' if v > 0 else ('neg' if v < 0 else 'zero') }}">
                        {{ v > 0 and '+' or '' }}{{ v }}
                      </span>
                    </div>
                  </td>
                {% else %}
                  <td class="{{ 'current-player-cell' if is_current else '' }}">
                    <div class="cell">
                      <span class="total-pill">0</span>
                      <span class="delta-corner hidden">0</span>
                    </div>
                  </td>
                {% endif %}
              {% endfor %}
            </tr>

  <!-- üîÅ Past completed TB rounds -->
  {% set total_tb = game.playoff_history|length %}
  {% for round_scores in game.playoff_history | reverse %}
    {% set tb_num = total_tb - loop.index0 %}
    <tr>
      <th scope="row">TB {{ "%02d"|format(tb_num) }}</th>
      {% for p in tie_players %} {# Use the stable tie_players list #}
        {% set v = round_scores.get(p) %}
        {% if v is not none %}
          <td>
            <div class="cell">
              <span class="total-pill">{{ v > 0 and '+' or '' }}{{ v }}</span>
              <span class="delta-corner {{ 'pos' if v > 0 else ('neg' if v < 0 else 'zero') }}">
                {{ v > 0 and '+' or '' }}{{ v }}
              </span>
            </div>
          </td>
        {% else %}
          <td></td>
        {% endif %}
      {% endfor %}
    </tr>
  {% endfor %}

          </tbody>
        </table>


      {% elif game.phase == 'final_ranking' %}
        <!-- =========================
             FINAL RANKING PHASE
             ========================= -->
        <div id="final-capture">
          <div class="status-box">
            <img src="{{ url_for('static', filename='images/finalstanding1.png') }}" alt="Final Standings" class="final-standings-img">
          </div>

          {% set winner_name = game.winner or (game.final_standings and game.final_standings[0].name) %}
          {% if winner_name %}
            <div class="winner-banner" role="status" aria-live="polite">
              üèÜ Winner: {{ winner_name }}
            </div>
          {% endif %}

          <table class="scoreboard final" id="scoreboard">
            <thead> {# Add a caption for overall table context #}
              <tr><th scope="col">&nbsp;</th>
                {% for st in game.final_standings %}
                  <th scope="col">{% set r=st.rank %}{% set sfx='th' %}
                      {% if r % 10 == 1 and r % 100 != 11 %}{% set sfx='st' %}{% endif %}
                      {% if r % 10 == 2 and r % 100 != 12 %}{% set sfx='nd' %}{% endif %}
                      {% if r % 10 == 3 and r % 100 != 13 %}{% set sfx='rd' %}{% endif %}
                      {{ r }}{{ sfx }}</th>
                {% endfor %}
              </tr>
              <tr><th scope="col">Player</th>
                {% for st in game.final_standings %}
                  <th scope="col">
                    {{ 'üèÜ ' if st.rank == 1 else '' }}
                    {% if game.final_standings|length > 4 %}
                      {{ st.name.split(' ')|map('first')|join('')|upper }}
                    {% else %}
                      {{ st.name }}
                    {% endif %}
                  </th>
                {% endfor %}
              </tr>
            </thead>
            <tbody>
              <tr class="total-row"><th scope="row">Final</th>
                {% for st in game.final_standings %}
                  {% set s = st.score %}
                  <td>{% if s>0 %}+{% endif %}{{ s }}</td>
                {% endfor %}
              </tr>

              {% for i in range(game.max_playoff_rounds, 0, -1) %}
                <tr><th>TB {{ "%02d"|format(i) }}</th>
                  {% for st in game.final_standings %} {# This is a data cell, not a header #}
                    {% set hist = game.all_playoff_history.get(st.name, []) %}
                    {% if i <= hist|length %}
                      {% set v = hist[i-1] %}
                      <td>{% if v>0 %}+{% endif %}{{ v }}</td>
                    {% else %}
                      <td>-</td>
                    {% endif %}
                  {% endfor %}
                </tr>
              {% endfor %}

              {% set rp = game.rounds_played or 0 %}
              {% for i in range(rp - 1, -1, -1) %}
                <tr><th scope="row">{{ "%02d"|format(i + 1) }}</th>
                  {% for st in game.final_standings %}
                    {% set v = game.round_history[i].get(st.name) %}
                    {% if v is not none %}
                      {% set ns = namespace(total=0) %}
                      {% for r in range(i + 1) %}
                        {% set ns.total = ns.total + (game.round_history[r].get(st.name, 0)) %}
                      {% endfor %}
                      <td>
                        <div class="cell">
                          <span class="total-pill">{{ ns.total>0 and '+' or '' }}{{ ns.total }}</span>
                          <span class="delta-corner {{ 'pos' if v>0 else ('neg' if v<0 else 'zero') }}">
                            {{ v>0 and '+' or '' }}{{ v }}
                          </span>
                        </div>
                      </td>
                    {% else %}
                      <td></td>
                    {% endif %}
                  {% endfor %}
                </tr>
              {% endfor %}
            </tbody>
          </table>
        </div>
      {% endif %}
    {% endif %}
  </div>

  <!-- =========================================================
       MODALS
       ========================================================= -->
  <div id="confirmOverlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="confirmTitle" aria-describedby="confirmMessage">
      <h3 id="confirmTitle">Confirm</h3>
      <p id="confirmMessage">Are you sure?</p>
      <div class="modal-actions">
        <button type="button" class="btn btn-cancel" id="confirmCancelBtn">Cancel</button>
        <button type="button" class="btn btn-confirm" id="confirmOkBtn">OK</button>
      </div>
    </div>
  </div>

  <!-- Settings Modal (with Add to Home Screen button) -->
  <div id="settingsOverlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="settingsTitle">
      <h3 id="settingsTitle">Settings</h3>
      <div class="settings-grid">


        <div class="settings-group">
          <label style="display:flex; align-items:center; gap:10px; font-weight:700;">
            <input id="hapticsToggle" type="checkbox">
            Haptic feedback
          </label>
          <div class="settings-help">Android: vibration ¬∑ iOS: subtle tap sound</div>
        </div>

        <!-- Rudeness Slider -->
        <div class="settings-group" id="rudenessSettingsRow">
          <label for="rudenessSlider" style="font-weight: 700; display: block;">
            Rudeness: <span id="rudenessLabel">Serious</span>
          </label>
          <div id="rudenessSlider" class="slider-container">
            <div class="slider-track"></div>
            <div class="slider-thumb"></div>
          </div>
          <div class="settings-help">
            Adjust the tone of the score announcements.
          </div>
        </div>
        
        <!-- Holes setting (only in setup) -->
        <div class="settings-group" id="holesSettingsRow" style="display: none;">
          <label for="holesInput" style="font-weight: 700; display: block;">Number of Rounds (Holes)</label>
          <input id="holesInput" type="number" class="settings-input" min="1" max="50" step="1" style="width: 100%; box-sizing: border-box; padding: 12px; background: #101010; border: 1px solid var(--border-color); border-radius: 8px; color: #fff;">
          <div class="settings-help" style="margin-top: 8px;">
            Set the game length. Can only be changed before the game starts.
          </div>
        </div>
        <!-- Clear Recent Players -->
        <div class="settings-group" style="display: flex; justify-content: space-between; align-items: center;">
          <div>
            <label style="font-weight: 700;">Recent Players</label>
            <div class="settings-help">Remove all names from the "Recent players" list.</div>
          </div>
          <button type="button" id="clearRecentsBtn" class="btn btn-cancel" title="Clear Recent Players" style="background-color: #582828; border: 1px solid #8c4343; flex-shrink: 0; padding: 12px 16px; font-size: 1.2em; line-height: 1;">
            ‚úï
          </button>
        </div>
        <!-- Add to Home Screen button (shown when eligible) -->
        <div class="settings-group">
          <button type="button" id="installBtnSettings" class="btn btn-confirm" style="display:none;">
            ‚ûï Add to Home Screen
          </button>
          <div class="settings-help">Install this app as a shortcut on your device.</div>
        </div>
      </div>
      <div class="modal-actions" style="margin-top:12px;">
        <button type="button" class="btn btn-cancel" onclick="closeSettings()">Close</button>
        <button type="button" class="btn btn-confirm" onclick="saveSettings()">Save</button>
      </div>
      <div class="settings-help" style="margin-top:8px;">
        Current: <b id="settingsSummary"></b>
      </div>
    </div>
  </div>

  <!-- iOS Add-to-Home instructions -->
  <div id="iosInstallOverlay" class="modal-overlay" aria-hidden="true">
    <div class="modal" role="dialog" aria-modal="true" aria-labelledby="iosInstallTitle">
      <h3 id="iosInstallTitle">Add to Home Screen</h3>
      <p style="margin-top:6px;">
        On iPhone/iPad (Safari): tap the <b>Share</b> button, then choose <b>Add to Home Screen</b>.
      </p>
      <div class="modal-actions" style="margin-top:12px;">
        <button type="button" class="btn btn-confirm" onclick="closeIosInstall()">OK</button>
      </div>
    </div>
  </div>

  <!-- Toast host -->
  <div id="toastHost" class="toast-container" aria-live="polite" aria-atomic="true"></div>

  <!-- =========================================================
       SCRIPT: INITIAL SERVER STATE INJECTION
       ========================================================= -->
  <script>window.__gameCache = {{ game | tojson | safe }};</script>

  <!-- =========================================================
       SCRIPT: CONFIRM HELPER
       ========================================================= -->
  <script>
    (function(){
      const overlay = document.getElementById('confirmOverlay');
      const titleEl = document.getElementById('confirmTitle');
      const msgEl   = document.getElementById('confirmMessage');
      const okBtn   = document.getElementById('confirmOkBtn');
      const cancelBtn = document.getElementById('confirmCancelBtn');
      let resolvePromise = null;

      function openModal(opts){
        const { title='Confirm', message='Are you sure?', okText='OK', cancelText='Cancel' } = opts || {};
        titleEl.textContent = title;
        msgEl.textContent   = message;
        okBtn.textContent   = okText;
        cancelBtn.textContent = cancelText;
        overlay.classList.add('show');
        document.body.style.overflow = 'hidden';
        setTimeout(() => okBtn.focus(), 0);
        return new Promise(resolve => { resolvePromise = resolve; });
      }
      function closeModal(result){
        overlay.classList.remove('show');
        document.body.style.overflow = '';
        if (resolvePromise){ const r = resolvePromise; resolvePromise = null; r(result); }
      }
      okBtn.addEventListener('click', ()=> closeModal(true));
      cancelBtn.addEventListener('click', ()=> closeModal(false));
      overlay.addEventListener('click', (e)=>{ if(e.target === overlay) closeModal(false); }); // Close on backdrop click
      window.addEventListener('keydown', (e)=>{ if (overlay.classList.contains('show') && e.key === 'Escape') closeModal(false); });
      window.showConfirmModal = openModal;
    })();
  </script>

  <!-- =========================================================
       SCRIPT: TOAST HELPERS
       ========================================================= -->
  <script>
    function showToast(message, type='info', ms=2200){
      const host = document.getElementById('toastHost');
      function popButton(el) {
        if (!el) return;
        el.classList.add('pop-animation');
        el.addEventListener('animationend', () => el.classList.remove('pop-animation'), { once: true });
      }

      if(!host) return ()=>{};
      const t = document.createElement('div');
      t.className = 'toast toast--' + type;
      t.textContent = message;
      host.appendChild(t);
      requestAnimationFrame(()=> t.classList.add('show'));
      const remove = ()=> { t.classList.remove('show'); setTimeout(()=> t.remove(), 200); };
      setTimeout(remove, ms);
      return remove;
    }
    function showActionToast(message, actionText, onClick, type='info', ms=6000){
      const host = document.getElementById('toastHost');
      if(!host) return ()=>{};
      const t = document.createElement('div');
      t.className = 'toast toast--' + type;
      const span = document.createElement('span');
      span.textContent = message;
      const btn = document.createElement('button');
      btn.textContent = actionText;
      btn.addEventListener('click', ()=>{ try{ onClick(); }catch(e){} remove(); });
      t.appendChild(span); t.appendChild(btn);
      host.appendChild(t);
      requestAnimationFrame(()=> t.classList.add('show'));
      const remove = ()=> { t.classList.remove('show'); setTimeout(()=> t.remove(), 200); };
      setTimeout(remove, ms);
      return remove;
    }
  </script>

  <!-- =========================================================
       SCRIPT: HAPTIC FEEDBACK
       ========================================================= -->
  <script>
  (function(){
    const HAPTIC_KEY = 'darts-haptics-enabled';
    function isHapticsOn(){ const v = localStorage.getItem(HAPTIC_KEY); return v === null ? true : v === '1'; }
    function setHaptics(on){ localStorage.setItem(HAPTIC_KEY, on ? '1' : '0'); }
    window.hapticsPref = { isOn: isHapticsOn, set: setHaptics };

    let audioCtx;
    function ensureAudio(){
      if (!audioCtx) {
        const AC = window.AudioContext || window.webkitAudioContext;
        audioCtx = AC ? new AC() : null;
      }
      if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume();
      return audioCtx;
    }
    function softClick(ms=70, freq=70){
      const ctx = ensureAudio(); if (!ctx) return;
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();
      osc.type = 'square';
      osc.frequency.value = freq;
      const t0 = ctx.currentTime;
      gain.gain.setValueAtTime(0, t0);
      gain.gain.linearRampToValueAtTime(0.16, t0 + 0.006);
      gain.gain.exponentialRampToValueAtTime(0.001, t0 + ms/1000);
      osc.connect(gain); gain.connect(ctx.destination);
      osc.start(t0); osc.stop(t0 + ms/1000 + 0.03);
    }
    function doubleClick(){ softClick(60, 85); setTimeout(()=> softClick(70, 60), 70); }

    const PATTERNS = { light:30, medium:[24,40,24], success:[20,40,20,50,70] };
    function tryVibrate(kind){
      if (!('vibrate' in navigator)) return false;
      const pattern = kind==='medium' ? PATTERNS.medium : (kind==='success' ? PATTERNS.success : PATTERNS.light);
      try{ return !!navigator.vibrate(pattern); }catch{ return false; }
    }

    window.haptic = function(kind='light'){
      if (!isHapticsOn()) return;
      const ok = tryVibrate(kind);
      if (ok) return;
      if (kind==='light') softClick(70, 70);
      else if (kind==='medium') doubleClick();
      else if (kind==='success'){ softClick(60, 90); setTimeout(()=> softClick(80, 50), 90); }
      else softClick(70, 70);
    };
    ['touchstart','mousedown','keydown'].forEach(ev=>{
      window.addEventListener(ev, ()=>{ ensureAudio(); }, { once:true, passive:true });
    });
    window.testHaptics = function(){
      const ok = tryVibrate('medium');
      if (!ok) doubleClick();
    };
  })();
  </script>

  <!-- =========================================================
       SCRIPT: PWA INSTALL (button lives in Settings)
       ========================================================= -->
  <script>
    (function(){
      const installBtn  = document.getElementById('installBtnSettings');
      const iosOverlay  = document.getElementById('iosInstallOverlay');
      let deferredPrompt = null;

      function isStandalone(){
        return window.matchMedia('(display-mode: standalone)').matches || window.navigator.standalone === true;
      }
      function isIOS(){ return /iPhone|iPad|iPod/i.test(navigator.userAgent); }
      function isSafari(){ return isIOS() && /Safari/i.test(navigator.userAgent) && !/CriOS|FxiOS|EdgiOS/i.test(navigator.userAgent); }

      function showInstallBtn(){ if (installBtn) installBtn.style.display = 'inline-block'; }
      function hideInstallBtn(){ if (installBtn) installBtn.style.display = 'none'; }

      function openIosInstall(){
        if (!iosOverlay) return;
        iosOverlay.classList.add('show');
        document.body.style.overflow = 'hidden';
      }
      window.closeIosInstall = function(){
        if (!iosOverlay) return;
        iosOverlay.classList.remove('show');
        document.body.style.overflow = '';
      };

      window.updateInstallVisibility = function(){
        if (isStandalone()){ hideInstallBtn(); return; }
        if (deferredPrompt || isSafari()) showInstallBtn();
        else hideInstallBtn();
      };

      window.addEventListener('beforeinstallprompt', (e) => {
        e.preventDefault();
        deferredPrompt = e;
        window.updateInstallVisibility();
      });

      window.addEventListener('appinstalled', () => {
        hideInstallBtn();
        showToast('App installed! üéâ', 'success');
        deferredPrompt = null;
      });

      installBtn?.addEventListener('click', async () => {
        if (isStandalone()) { showToast('Already installed', 'warning'); hideInstallBtn(); return; }
        if (deferredPrompt) {
          deferredPrompt.prompt();
          try {
            const choice = await deferredPrompt.userChoice;
            if (choice && choice.outcome === 'accepted') {
              showToast('Installing‚Ä¶', 'warning');
            }
          } finally {
            deferredPrompt = null;
            setTimeout(window.updateInstallVisibility, 0);
          }
        } else if (isSafari()) {
          openIosInstall();
        } else {
          showToast('Install not supported in this browser', 'warning');
        }
      });

      document.addEventListener('DOMContentLoaded', window.updateInstallVisibility);
    })();
  </script>

  <!-- =========================================================
       SCRIPT: GLOBAL HELPER FUNCTIONS
       ========================================================= -->
  <script>
    function popButton(el) {
      if (!el) return;
      el.classList.add('pop-animation');
      el.addEventListener('animationend', () => el.classList.remove('pop-animation'), { once: true });
    }
    function escapeHtml(s){
      return String(s).replace(/[&<>"']/g, (c)=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[c]));
    }
    function norm(s){ return (s||'').trim().replace(/\s+/g,' '); }
  </script>
  {% if (game.phase == 'playing' or game.phase == 'playoff') and not show_stats %}
  <!-- =========================================================
       SCRIPT: PLAYING / PLAYOFF CLIENT RENDER & ACTIONS
       ========================================================= -->
  <script>
    function qs(s){ return document.querySelector(s); }

    // Wake Lock
    let wakeLock;
    async function keepAwake(on){
      try{
        if(on && 'wakeLock' in navigator){
          wakeLock = await navigator.wakeLock.request('screen');
          wakeLock.addEventListener('release',()=>{});
        } else {
          await wakeLock?.release();
          wakeLock = null;
        }
      }catch(e){}
    }

    // Keyboard shortcuts
    document.addEventListener('keydown', (e)=>{
      const map = { '1':-3, '2':-2, '3':-1, '4':0, '5':+1, '6':+2, '0':0, 'u':'undo', 'U':'undo' };
      if(!(e.key in map)) return;
      e.preventDefault();
      if (map[e.key]==='undo') { undo(); return; }
      // For keyboard, we don't have a button to animate, so we pass `null`
      // to the hit function to prevent the page-pop animation.
      hit(map[e.key], null);
    });

    // Local save (resume)
    const SAVE_KEY='darts-golf-game';
    function saveLocal(game){ try{ localStorage.setItem(SAVE_KEY, JSON.stringify(game||{})); }catch(_){ } }
    function loadLocal(){ try{ return JSON.parse(localStorage.getItem(SAVE_KEY) || 'null'); }catch(_){ return null; } }

    // Track end state for confirm prompts
    let END_ACTIVE = {{ 'true' if game.end_after_round else 'false' }};

    function updateEndButtonLabel(active){
      var b = document.getElementById('endBtn');
      if (b) b.textContent = active ? 'Cancel' : 'End';
    }

    // ---- Anti-flicker sequencing + micro-batching ----
    let __opCounter = 0;
    let __lastCommittedOp = 0;
    let __applyTimer = null;

    function scheduleApplyFromServer(game, opId, force = false) {
      if (force) {
        __lastCommittedOp = Math.max(__lastCommittedOp, opId);
        window.__gameCache = game;
        saveLocal(game);
        renderGame(game);
        return;
      }
      if (opId !== __opCounter) return;
      if (__applyTimer) clearTimeout(__applyTimer);
      __applyTimer = setTimeout(() => {
        if (opId !== __opCounter) return;
        __lastCommittedOp = opId;
        window.__gameCache = game;
        saveLocal(game);
        renderGame(game);
      }, 64);
    }

    async function sendScore(val){
      const snapshot = window.__gameCache ? JSON.parse(JSON.stringify(window.__gameCache)) : null;
      const opId = ++__opCounter;

      try{
        // Optimistic
        if (window.__gameCache){
          const isPlayoff = window.__gameCache.phase === 'playoff';
          const playerToAnimate = isPlayoff ? window.__gameCache.playoff_group[window.__gameCache.current_player_index] : window.__gameCache.players[window.__gameCache.current_player_index];
          const playerIndexToAnimate = window.__gameCache.current_player_index; // For main game logic

          const g = JSON.parse(JSON.stringify(window.__gameCache));
          if (g.phase === 'playing'){
            const pIdx = g.current_player_index;
            const player = g.players[pIdx];
            const roundI = g.current_round - 1;

            g.round_history[roundI] = g.round_history[roundI] || {};
            g.scores[player] = (g.scores[player] || 0) + val;
            g.round_history[roundI][player] = val;

            g.undo_history = g.undo_history || [];
            g.undo_history.push({ player_index: pIdx, score_change: val });

            const lastIndex = g.players.length - 1;
            const wasLast   = pIdx === lastIndex;
            if (!(wasLast && g.end_after_round)) {
              g.current_player_index = wasLast ? 0 : pIdx + 1;
              if (wasLast) g.current_round += 1;
            }
          } else if (g.phase === 'playoff'){
            const pIdx = g.current_player_index;
            const player = g.playoff_group[pIdx];
            g.playoff_round_scores = g.playoff_round_scores || {};
            g.playoff_round_scores[player] = val;
            // Only advance the index if it's not the last player in the group.
            const isLastPlayerOfRound = (pIdx === g.playoff_group.length - 1);
            if (isLastPlayerOfRound) {
              // Round is over. Server will resolve it. Optimistically reset for next round.
              g.playoff_round_scores = {};
              g.playoff_group = []; // The server will send the new, smaller group.
              g.current_player_index = 0;
            } else {
              g.current_player_index = pIdx + 1;
            }
          }
          window.__gameCache = g;
          saveLocal(g);
          renderGame(g);
          triggerDeltaAnimation(playerToAnimate, val, isPlayoff);
        }

        const res = await fetch('{{ url_for("api_score") }}', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify({score:val}) });
        if (!res.ok){ if (__opCounter === opId && snapshot){ window.__gameCache = snapshot; renderGame(snapshot); __lastCommittedOp = opId; } showToast('Couldn‚Äôt save score ‚Äî connection error', 'error'); return; }
        const data = await res.json();
        if (!data.ok){ if (__opCounter === opId && snapshot){ window.__gameCache = snapshot; renderGame(snapshot); __lastCommittedOp = opId; } showToast('Couldn‚Äôt save score ‚Äî server rejected', 'error'); return; }

        if (data.game.phase === 'final_ranking') { location.reload(); return; }

        const force = (data.game.phase !== 'playing' || window.__gameCache.phase !== 'playing');
        scheduleApplyFromServer(data.game, opId, force);
      }catch(e){
        if (__opCounter === opId && snapshot){ window.__gameCache = snapshot; renderGame(snapshot); __lastCommittedOp = opId; }
        showToast('Couldn‚Äôt save score ‚Äî offline?', 'error');
        console.error('Score sync failed', e);
      }
    }

    async function undo(){
      const g0 = window.__gameCache;
      if (!g0 || g0.phase !== 'playing'){ showToast('Undo not available now', 'warning', 1400); return; }
      if (!g0.undo_history || !g0.undo_history.length){ showToast('Nothing to undo', 'warning', 1400); return; }

      const snapshot = JSON.parse(JSON.stringify(g0));
      const opId = ++__opCounter;

      try{
        const g = JSON.parse(JSON.stringify(g0));
        const n = g.players.length;

        const last_move = g.undo_history.pop();
        const prev_idx = (g.current_player_index - 1 + n) % n;
        g.current_player_index = prev_idx;

        if (prev_idx === n - 1){
          g.current_round = Math.max(1, g.current_round - 1);
        }

        const player_to_undo = g.players[prev_idx];
        const current_round_index = g.current_round - 1;
        g.scores[player_to_undo] = (g.scores[player_to_undo] || 0) - (last_move.score_change || 0);
        g.round_history[current_round_index] = g.round_history[current_round_index] || {};
        delete g.round_history[current_round_index][player_to_undo];

        window.__gameCache = g;
        saveLocal(g);
        renderGame(g);

        const res = await fetch('{{ url_for("api_undo") }}', { method:'POST' });
        if (!res.ok){ if (__opCounter === opId){ window.__gameCache = snapshot; renderGame(snapshot); __lastCommittedOp = opId; } showToast('Undo failed ‚Äî connection error', 'error'); return; }
        const data = await res.json();
        if (!data.ok){ if (__opCounter === opId){ window.__gameCache = snapshot; renderGame(snapshot); __lastCommittedOp = opId; } showToast('Undo failed ‚Äî server rejected', 'error'); return; }

        const force = (data.game.phase !== 'playing' || window.__gameCache.phase !== 'playing');
        scheduleApplyFromServer(data.game, opId, force);
      }catch(e){
        if (__opCounter === opId){ window.__gameCache = snapshot; renderGame(snapshot); __lastCommittedOp = opId; }
        showToast('Undo failed ‚Äî offline?', 'error');
        console.error('Undo sync failed', e);
      }
    }

    async function toggleEnd(){
      if (!END_ACTIVE) {
        const ok = await window.showConfirmModal({ title: 'End', message: 'The game will end after ALL players finish THIS round. Continue?', okText: 'End', cancelText: 'Cancel' });
        if (!ok) return;
      } else {
        const ok = await window.showConfirmModal({ title: 'Cancel End', message: 'The game will continue normally after this round. Continue?', okText: 'Cancel End', cancelText: 'Keep Ending' });
        if (!ok) return;
      }
      var res = await fetch('{{ url_for('api_end_after_round') }}', {method:'POST'});
      var data = await res.json(); if(!data.ok) return;
      window.__gameCache = data.game;
      saveLocal(data.game);
      renderGame(data.game);
    }

    function renderGame(g){
      keepAwake(g.phase==='playing' || g.phase==='playoff');

      if(g.phase==='playing'){ renderPlaying(g); var u=qs('#undoBtn'); if(u) u.removeAttribute('disabled'); }
      else if(g.phase==='playoff'){ renderPlayoff(g); var u2=qs('#undoBtn'); if(u2) u2.setAttribute('disabled','disabled'); }

      END_ACTIVE = !!g.end_after_round;
      updateEndButtonLabel(END_ACTIVE);
    }

    // Function to trigger the delta animation on a specific cell
    function triggerDeltaAnimation(scoredPlayerName, scoreValue, isPlayoff) {
      let targetCell;
      const game = window.__gameCache; // Get current game state

      if (isPlayoff) {
        const headerThs = document.querySelectorAll('#scoreboard thead th:not(:first-child)');
        const colIndex = Array.from(headerThs).findIndex(th => th.dataset.playerName === scoredPlayerName);

        if (colIndex !== -1) {
          targetCell = document.querySelector(`#scoreboard .current-row td:nth-child(${colIndex + 2})`);
          if (targetCell) {
            // The cell was rendered empty. Now we fill it and animate it.
            const v = scoreValue;
            const signedV = (v > 0 ? '+' : '') + v;
            const deltaClass = v > 0 ? 'pos' : (v < 0 ? 'neg' : 'zero');

            // 1. Populate the cell's inner HTML with the score and delta elements.
            targetCell.innerHTML = `
              <div class="cell">
                <span class="total-pill">${signedV}</span>
                <span class="delta-corner ${deltaClass}">${signedV}</span>
              </div>
            `;

            // 2. Find the newly created delta corner and trigger its animation.
            const deltaCorner = targetCell.querySelector('.delta-corner');
            if (deltaCorner) {
              deltaCorner.classList.add('delta-animate-trigger');
              deltaCorner.addEventListener('animationend', () => deltaCorner.classList.remove('delta-animate-trigger'), { once: true });
            }
          }
        }
      } else {
        // Main game logic remains the same, as it works correctly.
        const roundRow = document.querySelector(`#scoreboard tbody tr:nth-child(2)`);
        targetCell = roundRow?.querySelectorAll('td')[game.current_player_index - 1];
        const deltaCorner = targetCell?.querySelector('.delta-corner');
        if (deltaCorner) {
          deltaCorner.classList.add('delta-animate-trigger');
          deltaCorner.addEventListener('animationend', () => deltaCorner.classList.remove('delta-animate-trigger'), { once: true });
        }
      }
    }

    function sign(v){ return v>0?'+':''; }

// Refactored function to update the info bar elements
    function updateInfoBar(g) {
      const infoBar = qs('#info-bar');
      if (!infoBar) return;

      const roundCountDiv = infoBar.querySelector('.round-count');
      const oldDigitSpan = roundCountDiv.querySelector('.old-digit');
      const newDigitSpan = roundCountDiv.querySelector('.new-digit');
      const roundLabelSpan = roundCountDiv.querySelector('.round-label');
      const roundTotalSpan = roundCountDiv.querySelector('.round-total');
      const turnInfoDiv = infoBar.querySelector('.turn-info');
      let endBannerWrap = infoBar.querySelector('.end-banner-wrap');

      // Determine current round number and label based on phase
      let currentRoundValue;
      let roundLabelText;
      let roundTotalText = '';

      if (g.phase === 'playing') {
        currentRoundValue = g.current_round;
        roundLabelText = 'ROUND';
        roundTotalText = `/ ${g.holes}`;
      } else if (g.phase === 'playoff') {
        currentRoundValue = g.playoff_round;
        roundLabelText = 'TIE-BREAKER';
        roundTotalText = ''; // No total rounds in playoff
      } else {
        return; // Not in a phase that uses this info bar
      }

      // Update Round Label
      roundLabelSpan.textContent = roundLabelText;

      // Update Round Number with animation
      const oldRoundNumberText = oldDigitSpan.textContent;
      const newRoundNumberText = String(currentRoundValue).padStart(2,'0');

      if (oldRoundNumberText !== newRoundNumberText) {
        // Set the new value to the new digit element
        newDigitSpan.textContent = newRoundNumberText;

        // Immediately reset newDigitSpan's position without transition to prepare for animation
        newDigitSpan.style.transition = 'none';
        newDigitSpan.style.transform = 'translateY(100%)'; // Start below
        newDigitSpan.style.opacity = '0';

        // Force reflow to apply the immediate reset before starting the actual animation
        void newDigitSpan.offsetWidth;

        // Enable transitions for the animation
        oldDigitSpan.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';
        newDigitSpan.style.transition = 'transform 0.3s ease-out, opacity 0.3s ease-out';

        // Start the animation
        oldDigitSpan.style.transform = 'translateY(-100%)';
        oldDigitSpan.style.opacity = '0';
        newDigitSpan.style.transform = 'translateY(0)';
        newDigitSpan.style.opacity = '1';

        // Update oldDigitSpan's text content immediately for logical state,
        // but visually it will still be the old number animating out.
        // This prevents re-triggering if updateInfoBar is called again before transitionend.
        oldDigitSpan.textContent = newRoundNumberText;

        // Clean up after animation completes
        newDigitSpan.addEventListener('transitionend', function handler() {
          newDigitSpan.removeEventListener('transitionend', handler); // Remove listener

          // Reset oldDigitSpan to its final visible state (it already has the correct text)
          oldDigitSpan.style.transform = 'translateY(0)';
          oldDigitSpan.style.opacity = '1';
          oldDigitSpan.style.transition = 'none'; // Disable transition for the reset

          // Reset newDigitSpan to its hidden, empty state
          newDigitSpan.textContent = ''; // Clear content
          newDigitSpan.style.transform = 'translateY(100%)';
          newDigitSpan.style.opacity = '0';
          newDigitSpan.style.transition = 'none'; // Disable transition for immediate reset
        }, { once: true });
      } else {
        // If no change, ensure old digit is visible and new digit is hidden/empty
        oldDigitSpan.textContent = newRoundNumberText;
        oldDigitSpan.style.transform = 'translateY(0)';
        oldDigitSpan.style.opacity = '1';
        oldDigitSpan.style.transition = 'none'; // Ensure no lingering transitions

        newDigitSpan.textContent = ''; // Ensure new digit is empty
        newDigitSpan.style.transform = 'translateY(100%)';
        newDigitSpan.style.opacity = '0';
        newDigitSpan.style.transition = 'none'; // Ensure no lingering transitions
      }
      if (g.phase === 'playing') {
        roundTotalSpan.textContent = roundTotalText;
        roundTotalSpan.style.display = '';
      } else {
        roundTotalSpan.style.display = 'none';
      }

      // 3. Update Turn Info
      let currentPlayerName;
      if (g.phase === 'playing') {
        currentPlayerName = g.players[g.current_player_index];
      } else if (g.phase === 'playoff') {
        currentPlayerName = g.playoff_group[g.current_player_index];
      }
      turnInfoDiv.textContent = currentPlayerName + "'s Turn";

      // 4. Update End Banner (only for playing phase)
      if (g.phase === 'playing' && g.end_after_round) {
        if (!endBannerWrap) {
          endBannerWrap = document.createElement('div');
          endBannerWrap.className = 'end-banner-wrap';
          endBannerWrap.innerHTML = '<div class="end-banner"></div>';
          infoBar.appendChild(endBannerWrap);
        }
        endBannerWrap.querySelector('.end-banner').textContent = 'Game will end after this round. Finish all players this round to finalize and run tie-breakers.';
        endBannerWrap.style.display = '';
      } else {
        if (endBannerWrap) endBannerWrap.style.display = 'none';
      }
    }

    function renderPlaying(g){
      updateInfoBar(g); // Update the info bar elements

      var useInitials = g.players.length > 4;
      var headers = g.players.map(function(p, i) {
        var displayName = useInitials
          ? p.split(' ').map(function(w) { return w[0] || ''; }).join('').toUpperCase()
          : p;
        var isCurrent = i === g.current_player_index;
        return '<th class="'+(isCurrent ? 'current-player-header' : '')+'">'+displayName+'</th>';
      }).join('');
      var thead = '<thead><tr><th>&nbsp;</th>' + headers + '</tr></thead>';

      var totals = g.players.map(function(p){
        var s = g.scores[p] || 0;
        return '<td>'+sign(s)+s+'</td>';
      }).join('');

      var tbody = '<tbody><tr class="total-row"><th>Total</th>'+totals+'</tr>';

      var justWrappedRound = g.current_player_index === 0 && g.current_round > 1;

      var curIdx = g.current_round - 1;
      var curRow = g.round_history[curIdx] || {};
      var currentCells = g.players.map(function(p, pIdx){
        var v = curRow[p]; // Score for this player in this round
        var isCurrentPlayerForCell = (pIdx === g.current_player_index && typeof v === 'undefined');
        if (typeof v === 'undefined') {
          // This is an empty cell, apply highlight if it's the current player's turn
          return '<td class="' + (isCurrentPlayerForCell ? 'current-player-cell' : '') + '">' +
                 '<div class="cell"><span class="total-pill">0</span><span class="delta-corner hidden">0</span></div>' +
                 '</td>';
        }
        // This cell has a score, render it normally
        var running = g.round_history.slice(0, g.current_round).reduce(function(sum, rh){ return sum + (rh[p]||0); }, 0);
        return '<td><div class="cell"><span class="total-pill">'+(running>0?'+':'')+running+'</span><span class="delta-corner '+(v>0?'pos':(v<0?'neg':'zero'))+'">'+(v>0?'+':'')+v+'</span></div></td>';
      }).join('');
      tbody += '<tr class="current-row"><th>'+String(g.current_round).padStart(2,'0')+'</th>'+currentCells+'</tr>';

      for(var i=g.current_round-2;i>=0;i--){
        var row = g.round_history[i] || {}; // This is a past round, no highlight needed.
        var cells = g.players.map(function(p) {
          var v = row[p];
          if (typeof v === 'undefined') return '<td></td>';
          var running = g.round_history.slice(0, i + 1).reduce(function(sum, rh) { return sum + (rh[p] || 0); }, 0);
          return '<td><div class="cell"><span class="total-pill">' + (running > 0 ? '+' : '') + running + '</span><span class="delta-corner ' + (v > 0 ? 'pos' : (v < 0 ? 'neg' : 'zero')) + '">' + (v > 0 ? '+' : '') + v + '</span></div></td>';
        }).join('');
        tbody += '<tr><th>'+String(i+1).padStart(2,'0')+'</th>'+cells+'</tr>';
      }

      tbody += '</tbody>';
      qs('#scoreboard').innerHTML = thead+tbody;
    }

    function renderPlayoff(g){
        updateInfoBar(g); // Update the info bar elements
        // ---- Build a stable header list (all players who ever appeared in this tie) ----
        var headerPlayers = g.playoff_pool || []; // Use the stable pool
        var curScores = g.playoff_round_scores || {};

        // THEAD with current shooter highlight when applicable
        var useInitials = headerPlayers.length > 4;
        var thead = '<thead><tr><th>&nbsp;</th>'+headerPlayers.map(function(p) {
          var isCur = (g.playoff_group && p === g.playoff_group[g.current_player_index]);
          var displayName = useInitials
            ? p.split(' ').map(function(w) { return w[0] || ''; }).join('').toUpperCase()
            : p;
          return '<th class="'+(isCur ? 'current-player-header' : '')+'" data-player-name="'+p+'">' + displayName + '</th>';
        }).join('')+'</tr></thead>';

        // TB totals (base score only)
        var totals = headerPlayers.map(function(){ var s = g.playoff_base_score || 0; return '<td>'+(s>0?'+':'')+s+'</td>'; }).join('');
        var tbody = '<tbody><tr class="total-row"><th>Total</th>'+totals+'</tr>';

        // ‚úÖ Current TB round row (stable columns)
        var currentCells = headerPlayers.map(function(p) {
          var v = curScores[p];
          // Determine if this cell belongs to the current player whose turn it is
          var isCurrentPlayerForCell = (g.playoff_group && p === g.playoff_group[g.current_player_index]);
          // For the player who just scored, render an empty cell. The animation function will fill it.
          // For all other players, render as normal.
          if (typeof v === 'undefined') {
            // Render an empty cell with the highlight if it's the current player's turn
            return '<td class="'+(isCurrentPlayerForCell ? 'current-player-cell' : '')+'"><div class="cell"><span class="total-pill"></span><span class="delta-corner hidden"></span></div></td>';
          }
          return '<td><div class="cell"><span class="total-pill">' + (v > 0 ? '+' : '') + v + '</span><span class="delta-corner ' + (v > 0 ? 'pos' : (v < 0 ? 'neg' : 'zero')) + '">' + (v > 0 ? '+' : '') + v + '</span></div></td>';
        }).join('');
        tbody += '<tr class="current-row"><th>TB '+String(g.playoff_round).padStart(2,'0')+'</th>'+currentCells+'</tr>';

      // üîÅ Past completed TB rounds (latest first)
      for (var idx = g.playoff_history.length - 1; idx >= 0; idx--) {
        var round_scores = g.playoff_history[idx] || {};
        var tbNum = idx + 1;
        var cells = headerPlayers.map(function(p){ // Use stable headerPlayers list
          var v = round_scores[p];
          if (typeof v === 'undefined') return '<td></td>';
          return (
            '<td>' +
              '<div class="cell">' +
                '<span class="total-pill">' + (v>0?'+':'') + v + '</span>' +
                '<span class="delta-corner ' + (v>0?'pos':(v<0?'neg':'zero')) + '">' + (v>0?'+':'') + v + '</span>' +
              '</div>' +
            '</td>'
          );
        }).join('');
        tbody += '<tr><th>TB ' + String(tbNum).padStart(2,'0') + '</th>' + cells + '</tr>';
      }


        tbody += '</tbody>';
        qs('#scoreboard').innerHTML = thead + tbody;
      }

    function hit(val, el){
      haptic('light');
      if (el) { // Only animate and position bubble if an element is provided
        popButton(el);
        showBubbleFor(val, el);
      } else {
        // For keyboard input, show bubble from the bottom of the screen
        showBubbleFor(val, null);
      }
      sendScore(val);
    }
    function showBubbleFor(val, el){
      // 1. Get the label text for the bubble
      const scoreLabels = window.__gameCache?.score_labels || {};
      var key = String(val), label = (typeof scoreLabels[key] !== 'undefined') ? scoreLabels[key] : (val>0?('+'+val):String(val));
      var cls = val > 0 ? 'pos' : (val < 0 ? 'neg' : 'zero');

      // 2. Create the bubble and add it to the DOM to measure it
      const bubble = document.createElement('div');
      bubble.className = `score-bubble ${cls}`;
      bubble.textContent = label;
      document.body.appendChild(bubble);

      // 3. Calculate its position, keeping it on-screen
      const rect = el?.getBoundingClientRect();
      const bubbleWidth = bubble.offsetWidth;
      const margin = 8; // 8px margin from screen edge

      // Default to center of button, or center of screen for keyboard input
      let x = rect ? rect.left + (rect.width / 2) : window.innerWidth / 2;
      let y = rect ? rect.top - 6 : window.innerHeight - 80;

      // Adjust x to prevent overflow
      x = Math.max(x, (bubbleWidth / 2) + margin); // Keep left edge on screen
      x = Math.min(x, window.innerWidth - (bubbleWidth / 2) - margin); // Keep right edge on screen

      bubble.style.left = `${x}px`; // The CSS transform will handle the centering
      bubble.style.top = `${y}px`;
      bubble.addEventListener('animationend', () => bubble.remove());
    }

    // --- Init on load ---
    document.addEventListener('DOMContentLoaded', () => {
      keepAwake(true);
      updateEndButtonLabel(END_ACTIVE);
    });
  </script>
  {% elif game.phase == 'setup' and not show_stats %}
  <!-- =========================================================
       SCRIPT: SETUP PAGE ‚Äî Pills with Pointer Events drag
       ========================================================= -->
  <script>
    const chipList         = document.getElementById('chipList');           // recent chips (if any)
    const selectedWrap     = document.getElementById('selectedWrap'); // container for selected chips
    const selectedChipList = document.getElementById('selectedChipList');
    const playersHidden    = document.getElementById('playersInput');       // hidden CSV posted to /start
    const nameField        = document.getElementById('nameField');
    const addNameBtn       = document.getElementById('addNameBtn');
    const startForm        = document.getElementById('startForm');

    // Initialize 'selected' array. If there was a form error, repopulate with the previous input.
    // Otherwise, start with an empty array.
    let selected = [];
    let allRecentNames = {{ (game.recent_names or []) | tojson | safe }};
    {% if previous_players %}
      selected = {{ previous_players.split(',') | map('trim') | list | tojson }};
    {% endif %}

    // ---------- Rendering ----------
    function renderSelected(){
      if (selected.length) {
        selectedChipList.innerHTML = selected.map((n, i) => (
          `<div class="chip draggable" data-name="${escapeHtml(n)}" title="Drag to reorder">
             <span class="chip-index">${i+1}</span>
             <span class="chip-name">${escapeHtml(n)}</span>
             <button type="button" class="chip-remove" aria-label="Remove ${escapeHtml(n)}" title="Remove">‚úï</button>
           </div>`
        )).join('');
      } else {
        selectedChipList.innerHTML = '<div class="empty-list-text">empty</div>';
      }
      bindSelectedEvents();
      writeHidden();
      renderRecent(); // Re-render recents to show/hide selected names
    }

    function renderRecent(){
      if (!chipList) return;
      const availableRecents = allRecentNames.filter(n => idxOfName(selected, n) < 0);

      if (availableRecents.length > 0) {
        chipList.innerHTML = availableRecents.map(n =>
          `<div class="chip" data-name="${escapeHtml(n)}">${escapeHtml(n)}</div>`
        ).join('');
      } else {
        chipList.innerHTML = '<div class="empty-list-text">empty</div>';
      }

      chipList.querySelectorAll('.chip[data-name]').forEach(el=>{
        el.addEventListener('click', ()=>{
          const name = el.getAttribute('data-name');
          addName(name); // Clicking a recent now only adds it
        });
      });
    }

    function writeHidden(){
      playersHidden.value = selected.join(', ');
    }

    // ---------- Add / Remove Logic ----------
    function addName(raw){
      const name = norm(raw);
      if (!name) return;
      if (name.length > 14) {
        showToast('Name cannot be longer than 14 characters.', 'warning', 3000);
        return;
      }

      if (idxOfName(selected, name) >= 0) { // Duplicate detected
        // Only show toast if it was a manual entry, not a click on a recent pill
        // (which shouldn't be possible anyway with the new logic, but this is safer)
        if (nameField.value.trim().toLowerCase() === name.toLowerCase()) {
          showToast(`Duplicate name: ${name}`, 'warning', 3000);
        }
        return;
      }
      selected.push(name);
      renderSelected();
      nameField.value = '';
      nameField.focus();
      haptic('light');
    }

    function removeName(name){
      const i = idxOfName(selected, name);
      if (i >= 0){
        selected.splice(i,1);
        renderSelected(); // re-number pills
      }
    }

    // Delegated click for ‚úï remove
    selectedChipList.addEventListener('click', (e)=>{
      const btn = e.target.closest('.chip-remove');
      if (!btn) return;
      e.preventDefault();
      e.stopPropagation();
      const chip = btn.closest('.draggable');
      if (!chip) return;
      const name = chip.getAttribute('data-name');
      removeName(name);
    });

    // ---------- Helpers ----------
    function idxOfName(arr, name){
      const n = name.toLowerCase();
      for (let i=0;i<arr.length;i++) if (arr[i].toLowerCase()===n) return i;
      return -1;
    }
    // ---------- Desktop HTML5 DnD fallback (only if no Pointer Events) ----------
    function bindSelectedEvents(){
      const hasPointer = 'PointerEvent' in window;
      selectedChipList.querySelectorAll('.draggable').forEach(chip=>{
        if (!hasPointer){
          chip.setAttribute('draggable','true');
          chip.addEventListener('dragstart', (e)=>{ chip.classList.add('dragging'); e.dataTransfer.effectAllowed='move'; });
          chip.addEventListener('dragend',   ()=> chip.classList.remove('dragging'));
        } else {
          chip.removeAttribute('draggable'); // prevent native DnD when using Pointer Events
        }
      });

      if (!hasPointer) {
        selectedChipList.addEventListener('dragover', (e)=>{
          e.preventDefault();
          const after = getAfter(selectedChipList, e.clientY);
          const dragging = selectedChipList.querySelector('.dragging');
          if (!dragging) return;
          if (!after) selectedChipList.appendChild(dragging);
          else selectedChipList.insertBefore(dragging, after);
        });
        selectedChipList.addEventListener('drop', ()=>{
          commitOrderFromDom(); // re-render to update numbering
        });
      }
    }

    function getDropTarget(container, y){
      const els = [...container.querySelectorAll('.draggable:not(.dragging)')];
      return els.reduce((closest, child)=>{
        const box = child.getBoundingClientRect();
        const offset = y - box.top - box.height/2;
        return (offset < 0 && offset > closest.offset) ? {offset, element: child} : closest;
      }, {offset: Number.NEGATIVE_INFINITY, element: null}).element;
    }

    // ---------- Pointer Events drag (modern browsers) ----------
    ;(function(){
      if (!('PointerEvent' in window)) return;
      if (!document.getElementById('selectedChipList')) return;

      let active = null;        // element being dragged (original)
      let ghost = null;         // floating clone
      let placeholder = null;   // insertion marker
      let startX=0, startY=0;   // pointer down pos
      let offX=0, offY=0;       // offset within chip
      let dragging = false;
      let pointerId=null;

      const TOUCH_SLOP_SQ = 25; // 5px^2 threshold for touch
      function setBodyCursor(grabbing){ document.body.style.cursor = grabbing ? 'grabbing' : ''; }

      function createGhost(fromEl){
        const r = fromEl.getBoundingClientRect();
        const g = fromEl.cloneNode(true);
        g.style.position = 'fixed';
        g.style.left = r.left + 'px';
        g.style.top  = r.top  + 'px';
        g.style.width = r.width + 'px';
        g.style.height = r.height + 'px';
        g.style.pointerEvents = 'none';
        g.style.opacity = '0.85';
        g.style.boxSizing = 'border-box';
        g.classList.add('dragging');
        document.body.appendChild(g);
        return g;
      }
      function makePlaceholder(fromEl){
        const p = document.createElement('div');
        p.className = 'chip placeholder';
        p.style.width  = fromEl.offsetWidth + 'px';
        p.style.height = fromEl.offsetHeight + 'px';
        return p;
      }
      function indexFromPoint(x, y){
        const children = Array.from(selectedChipList.children).filter(el => el !== placeholder);
        if (!children.length) return 0;
        let bestIdx = children.length;
        let bestDist = Infinity;
        children.forEach((el, idx)=>{
          const r = el.getBoundingClientRect();
          const cx = r.left + r.width/2;
          const cy = r.top + r.height/2;
          const dx = cx - x, dy = cy - y;
          const d  = dx*dx + dy*dy;
          if (d < bestDist){ bestDist = d; bestIdx = idx; }
        });
        const near = children[bestIdx];
        if (!near) return children.length;
        const r = near.getBoundingClientRect();
        const before =
          (Math.abs(y - (r.top + r.height/2)) > Math.abs(x - (r.left + r.width/2)))
            ? (y < r.top + r.height/2)
            : (x < r.left + r.width/2);
        return before ? bestIdx : bestIdx + 1;
      }
      function commitOrderFromDom(){
        selected = Array
          .from(selectedChipList.querySelectorAll('.draggable'))
          .map(el=> el.getAttribute('data-name'));
        writeHidden();
        renderSelected(); // re-number after reorder
      }

      function startDrag(){
        if (!active || dragging) return;
        ghost = createGhost(active);
        placeholder = makePlaceholder(active);
        selectedChipList.insertBefore(placeholder, active);
        active.style.visibility = 'hidden'; // keep layout size; avoids jump
        dragging = true;
        setBodyCursor(true);
      }

      function onPointerDown(e){
        e.preventDefault();
        const rmBtn = e.target.closest('.chip-remove');
        if (rmBtn) return;

        const chip = e.target.closest('.draggable');
        if (!chip) return;

        active = chip;
        pointerId = e.pointerId;
        try { active.setPointerCapture(pointerId); } catch(_){ }

        const r = chip.getBoundingClientRect();
        startX = e.clientX; startY = e.clientY;
        offX = startX - r.left; offY = startY - r.top;
        dragging = false;

        if (e.pointerType === 'mouse') {
          startDrag();
        }
      }

      function onPointerMove(e){
        if (!active) return;

        if (!dragging){
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          const dist2 = dx*dx + dy*dy;
          if (e.pointerType !== 'mouse' && dist2 <= TOUCH_SLOP_SQ) return;
          startDrag();
        }

        e.preventDefault();
        const x = e.clientX - offX, y = e.clientY - offY;
        if (ghost){
          ghost.style.left = x + 'px';
          ghost.style.top  = y + 'px';
        }

        const idx = indexFromPoint(e.clientX, e.clientY);
        const target = document.getElementById('selectedChipList').children[idx];
        if (!target) selectedChipList.appendChild(placeholder);
        else selectedChipList.insertBefore(placeholder, target);
      }

      function onPointerUp(e){
        if (!active) return;

        if (dragging){
          if (placeholder && placeholder.parentNode){
            selectedChipList.insertBefore(active, placeholder);
          }
          active.style.visibility = '';
          placeholder?.remove(); placeholder = null;
          ghost?.remove(); ghost = null;
          commitOrderFromDom();
        }

        try { active.releasePointerCapture(pointerId); } catch(_){ }
        active = null;
        dragging = false;
        pointerId = null;
        setBodyCursor(false);
      }

      document.getElementById('selectedChipList').addEventListener('pointerdown', onPointerDown, { passive:false });
      window.addEventListener('pointermove', onPointerMove, { passive:false });
      window.addEventListener('pointerup', onPointerUp, { passive:false });
      window.addEventListener('pointercancel', onPointerUp, { passive:false });
      window.addEventListener('blur', onPointerUp, { passive:false });
    })();

    // ---------- Form UX ----------
    addNameBtn.addEventListener('click', ()=> addName(nameField.value));
    nameField.addEventListener('keydown', (e)=>{
      if (e.key === 'Enter'){
        e.preventDefault();
        addName(nameField.value);
      }
    });

    startForm.addEventListener('submit', (e)=>{
      if (!selected.length){
        e.preventDefault();
        showToast('Add at least one player', 'warning', 1600);
        nameField.focus();
        return;
      }
      writeHidden();
    });

    // ---------- Init ----------
    renderRecent();
    renderSelected();
  </script>
  {% endif %}

  {% if game.phase == 'final_ranking' and not show_stats %}
  <!-- =========================================================
       SCRIPT: CONFETTI ON WINNER
       ========================================================= -->
  <script id="confetti-script">
    (function(){
      const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
      if (prefersReduced) return;

      const canvas = document.getElementById('confettiCanvas');
      const ctx = canvas.getContext('2d');
      let W, H, raf = null;
      let pieces = [];
      function resize(){ W = canvas.width = window.innerWidth; H = canvas.height = window.innerHeight; }
      window.addEventListener('resize', resize); resize();

      function spawn(n){
        for(let i=0;i<n;i++){
          pieces.push({
            x: Math.random() * W, y: -20 - Math.random() * 20, // Start from just above the top, across the whole width
            vx: (Math.random()-0.5)*1, vy: 2+Math.random()*3,
            size: 5+Math.random()*8, rot: Math.random()*Math.PI, vr: (Math.random()-0.5)*0.2,
            shape: Math.random()<0.5?'rect':'tri',
            life: 2.0,
            fade: 0.002 + Math.random() * 0.005 // Make them last longer to reach the bottom
          });
        }
      }
      function step(){
        ctx.clearRect(0,0,W,H);
        let i = pieces.length;
        while (i--) {
          const p = pieces[i];
          p.life -= p.fade;
          if (p.life <= 0) {
            pieces.splice(i, 1);
            continue;
          }
          p.vy += 0.02; p.x += p.vx; p.y += p.vy; p.rot += p.vr; // A little more gravity
          ctx.save();
          ctx.globalAlpha = p.life;
          ctx.translate(p.x, p.y);
          ctx.rotate(p.rot);
          ctx.fillStyle = ['#E3292E','#309F6A','#F9DFBC','#ffffff','#ffd54f'][Math.floor(Math.random()*5)];
          if (p.shape==='rect'){ ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6); }
          else {
            ctx.beginPath();
            ctx.moveTo(0,-p.size/2); ctx.lineTo(p.size/2,p.size/2); ctx.lineTo(-p.size/2,p.size/2); ctx.closePath(); ctx.fill();
          }
          ctx.restore();
        }

        if (pieces.length > 0) {
          raf = requestAnimationFrame(step);
        } else {
          ctx.clearRect(0,0,W,H); // Final clear
          cancelAnimationFrame(raf);
          raf = null;
        }
      }
      spawn(300); // A bigger initial burst on page load
      if (!raf) raf = requestAnimationFrame(step);

      // Expose a function to trigger more confetti
      window.triggerConfetti = () => {
        let counter = 0;
        const streamInterval = setInterval(() => {
          spawn(20); // Spawn a small burst every 50ms
          if (!raf) raf = requestAnimationFrame(step);
          counter++;
          if (counter >= 20) clearInterval(streamInterval); // Stream for 1 second
        }, 50);
      };
    })();
  </script>
  {% endif %}

  <!-- =========================================================
       SCRIPT: GLOBAL SCROLL GUARD FOR iOS
       (blocks page rubber-band; only .container scrolls)
       ========================================================= -->
  <script>
    (function(){
      const scrollArea = document.querySelector('.container'); // only scrollable region
      let startY = 0;
      let insideScrollable = false;

      function isInsideScrollable(el) {
        let n = el;
        while (n && n !== document.body) {
          if (n === scrollArea) return true;
          n = n.parentElement;
        }
        return false;
      }

      document.addEventListener('touchstart', (e) => {
        insideScrollable = isInsideScrollable(e.target);
        startY = (e.touches && e.touches.length) ? e.touches[0].clientY : 0;
      }, { passive: true });

      document.addEventListener('touchmove', (e) => {
        if (!scrollArea) { e.preventDefault(); return; }

        // If touch is outside the scroll area, block it outright.
        if (!insideScrollable) { e.preventDefault(); return; }

        // Inside scroll area: block rubber-band when at edges and trying to go past
        const y = (e.touches && e.touches.length) ? e.touches[0].clientY : startY;
        const dy = y - startY;

        const atTop = scrollArea.scrollTop <= 0;
        const atBottom = scrollArea.scrollTop + scrollArea.clientHeight >= scrollArea.scrollHeight - 1;

        if ((atTop && dy > 0) || (atBottom && dy < 0)) {
          e.preventDefault(); // stop bounce from reaching <body>
        }
      }, { passive: false });

      // Block wheel/trackpad page scroll (iPadOS / desktop Safari)
      document.addEventListener('wheel', (e) => {
        if (!isInsideScrollable(e.target)) e.preventDefault();
      }, { passive: false });

      // Also hard-lock explicitly marked regions (e.g., bottom controls)
      document.querySelectorAll('[data-lock-scroll]').forEach(el=>{
        el.addEventListener('touchmove', e => e.preventDefault(), { passive:false });
        el.addEventListener('wheel',     e => e.preventDefault(), { passive:false });
      });
    })();
  </script>

  <!-- =========================================================
       SCRIPT: RAISE CONTROLS FOR IPHONE + SET CONTAINER BOTTOM INSET
       (fixed controls; only compute height; no extra spacer)
       ========================================================= -->
<script>
  (function(){
    const root = document.documentElement;
    const controls = document.querySelector('.controls');
    function setH(){ if (controls) root.style.setProperty('--controls-h', controls.getBoundingClientRect().height + 'px'); }
    window.addEventListener('load', setH, {once:true});
    window.addEventListener('resize', setH);
    window.addEventListener('orientationchange', setH);
    // iOS visual viewport changes
    if (window.visualViewport){
      visualViewport.addEventListener('resize', setH);
      visualViewport.addEventListener('scroll', setH);
    }
    document.addEventListener('visibilitychange', ()=>{ if(!document.hidden) setH(); });
  })();
</script>

  <!-- =========================================================
       CONTROLS (BOTTOM BAR)
       ========================================================= -->
  {% if show_stats %}
    <div class="controls no-overscroll" data-lock-scroll>
      <div class="button-grid two" data-lock-scroll>
        <a href="{{ url_for('index') }}" onclick="popButton(this.querySelector('button'));"><button type="button" class="export-btn">Back</button></a>
        <form id="restartForm" action="{{ url_for('restart') }}" method="post">
          <button type="button" id="restartBtn" class="restart-btn">New Game</button>
        </form>
      </div>
    </div>
  {% elif game.phase == 'setup' %}
    <!-- Bottom controls for SETUP ‚Äî unified button-grid two -->
    <div class="controls no-overscroll" data-lock-scroll>
      <div class="button-grid two" data-lock-scroll>
        <button type="button" class="settings-btn" onclick="popButton(this); openSettings();">Settings</button>
        <!-- Submit the existing #startForm from here -->
        <button type="submit" class="export-btn" form="startForm" onclick="popButton(this);">Start Game</button>
      </div>
    </div>
  {% elif game.phase in ['playing','playoff'] %}
    <div class="controls no-overscroll" data-lock-scroll>
      <div class="button-grid" data-lock-scroll>
        <button type="button" class="score-btn minus" onclick="hit(-3, this)">-3</button>
        <button type="button" class="score-btn minus" onclick="hit(-2, this)">-2</button>
        <button type="button" class="score-btn minus" onclick="hit(-1, this)">-1</button>
        <button type="button" class="score-btn zero"  onclick="hit(0,  this)">0</button>
        <button type="button" class="score-btn plus"  onclick="hit(1,  this)">+1</button>
        <button type="button" class="score-btn plus"  onclick="hit(2,  this)">+2</button>
      </div>
      <div class="button-grid two playing" data-lock-scroll>
        <button type="button" id="undoBtn" class="undo-btn" onclick="popButton(this); undo();" {{ 'disabled' if game.phase == 'playoff' else '' }}>Undo</button>
        <button type="button" id="endBtn" class="end-btn" onclick="popButton(this); toggleEnd();">{{ 'Cancel' if game.end_after_round else 'End' }}</button>
      </div>
    </div>
  {% elif game.phase == 'final_ranking' %}
    <div class="controls no-overscroll" data-lock-scroll>
      <div class="button-grid final-controls" data-lock-scroll>
        <a href="{{ url_for('stats') }}" onclick="popButton(this.querySelector('button'));"><button type="button" class="export-btn">Stats</button></a>
        <button type="button" id="confettiBtn" class="confetti-btn" onclick="popButton(this); window.triggerConfetti();">üéâ</button>
        <form id="restartForm" action="{{ url_for('restart') }}" method="post">
          <button type="button" id="restartBtn" class="restart-btn">New Game</button>
        </form>
      </div>
    </div>
  {% endif %}

  <!-- Attach confirm to Start New Game -->
  <script>
    (function(){
      var btn = document.getElementById('restartBtn');
      var form = document.getElementById('restartForm');
      if (btn && form) {
        btn.addEventListener('click', async function(){
          popButton(this);
          const ok = await window.showConfirmModal({
            title: 'Start New Game',
            message: 'This will clear the current game and return to setup. Continue?',
            okText: 'Start New Game',
            cancelText: 'Cancel'
          });
          if (ok) form.submit();
        });
      }
    })();
  </script>

  <!-- =========================================================
       SCRIPT: SETTINGS MODAL LOGIC
       ========================================================= -->
  <script>
    const settingsOverlay = document.getElementById('settingsOverlay');
    const hapticsToggle   = document.getElementById('hapticsToggle');
    const holesInput      = document.getElementById('holesInput');
    const holesRow        = document.getElementById('holesSettingsRow');
    const rudenessSlider  = document.getElementById('rudenessSlider');
    const rudenessLabel   = document.getElementById('rudenessLabel');
    const settingsSummary = document.getElementById('settingsSummary');
    const clearRecentsBtn = document.getElementById('clearRecentsBtn');    
    
    // --- Custom Rudeness Slider Logic ---
    const RUDENESS_MAP = ['Serious', 'Medium', 'Rude'];
    const rudenessThumb = rudenessSlider.querySelector('.slider-thumb');
    let rudenessLevel = 0; // Internal state for the slider's value

    function setRudenessSlider(level, animate = false) {
      rudenessLevel = Math.max(0, Math.min(level, RUDENESS_MAP.length - 1));
      rudenessLabel.textContent = RUDENESS_MAP[rudenessLevel];
      // Position is 0% for level 0, 50% for level 1, 100% for level 2
      const percent = (rudenessLevel / (RUDENESS_MAP.length - 1)) * 100;
      if (!animate) rudenessThumb.classList.add('dragging'); // Prevent animation on initial set
      rudenessThumb.style.left = `${percent}%`;
      if (!animate) {
        // Force reflow and then remove the class to re-enable animation for future interactions
        rudenessThumb.offsetHeight; 
        rudenessThumb.classList.remove('dragging');
      }
    }

    function handleSliderMove(clientX) {
      const rect = rudenessSlider.getBoundingClientRect();
      const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
      
      // Update thumb position visually while dragging
      rudenessThumb.style.left = `${percent * 100}%`;

      // Update the label in real-time
      const level = Math.round(percent * (RUDENESS_MAP.length - 1));
      rudenessLabel.textContent = RUDENESS_MAP[level];
    }

    function handleSliderEnd(clientX) {
      const rect = rudenessSlider.getBoundingClientRect();
      const percent = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
      const finalLevel = Math.round(percent * (RUDENESS_MAP.length - 1));
      setRudenessSlider(finalLevel, true); // Snap with animation
    }

    let isDragging = false;
    rudenessSlider.addEventListener('pointerdown', (e) => {
      isDragging = true;
      rudenessThumb.classList.add('dragging');
      rudenessSlider.setPointerCapture(e.pointerId);
      handleSliderMove(e.clientX);
    });
    rudenessSlider.addEventListener('pointermove', (e) => {
      if (!isDragging) return;
      handleSliderMove(e.clientX);
    });
    rudenessSlider.addEventListener('pointerup', (e) => {
      if (!isDragging) return;
      isDragging = false;
      rudenessThumb.classList.remove('dragging');
      rudenessSlider.releasePointerCapture(e.pointerId);
      handleSliderEnd(e.clientX);
    });
    // Also handle clicks on the track
    rudenessSlider.addEventListener('click', (e) => {
      // Prevent click from firing during a drag sequence
      if (e.target === rudenessThumb) return;
      handleSliderEnd(e.clientX);
    });


    function openSettings(){
      const g = window.__gameCache;
      hapticsToggle.checked = window.hapticsPref.isOn();
      holesInput.value = g.holes || 20;
      setRudenessSlider(g.rudeness_level || 0);

      // Only show the holes/rounds setting during the setup phase
      if (g.phase === 'setup') {
        holesRow.style.display = 'grid';
        holesInput.disabled = false;
      } else {
        holesRow.style.display = 'none';
        holesInput.disabled = true;
      }

      updateSettingsSummary();
      if (typeof window.updateInstallVisibility === 'function') {
        window.updateInstallVisibility();
      }
      settingsOverlay.classList.add('show');
      document.body.style.overflow = 'hidden';
    }
    function updateSettingsSummary() {
      const g = window.__gameCache;
      const hapticsStatus = window.hapticsPref.isOn() ? 'on' : 'off';
      const rudeness = RUDENESS_MAP[g.rudeness_level || 0];
      let summary = `haptics ${hapticsStatus}, ${rudeness}`;
      if (g.phase === 'setup') {

        summary += `, ${holesInput.value} rounds`;
      } else {
        summary += `, ${g.holes} rounds`;
      }
      settingsSummary.textContent = summary;
    }
    function closeSettings(){

      settingsOverlay.classList.remove('show');
      document.body.style.overflow = '';
    }
    async function saveSettings(){
      window.hapticsPref.set(!!hapticsToggle.checked);

      const payload = {};

      payload.rudeness_level = rudenessLevel;
      const g = window.__gameCache;
      if (g.phase === 'setup') {
        const newHoles = parseInt(holesInput.value, 10);
        if (newHoles && newHoles !== g.holes) {
          payload.holes = newHoles;
        }
      }

      try {
        const res = await fetch('{{ url_for("api_settings") }}', { method:'POST', headers:{'Content-Type':'application/json'}, body:JSON.stringify(payload) });
        const data = await res.json();
        if (data.ok && data.game) {
          window.__gameCache = data.game;
          if (typeof saveLocal === 'function') saveLocal(data.game);
          updateSettingsSummary();
        }
        showToast('Settings saved', 'success');
      } catch(e) { showToast('Could not save settings', 'error'); }
    }

    clearRecentsBtn.addEventListener('click', async () => {
      const ok = await window.showConfirmModal({
        title: 'Clear Recent Players',
        message: 'Are you sure you want to remove all recent player names? This cannot be undone.',
        okText: 'Clear',
        cancelText: 'Cancel'
      });
      if (!ok) return;

      try {
        const res = await fetch('{{ url_for("api_clear_recents") }}', { method: 'POST' });
        const data = await res.json();
        if (data.ok && data.game) {
          window.__gameCache = data.game;
          // Update the local recentNames variable before re-rendering
          window.recentNames = data.game.recent_names || [];
          if (typeof saveLocal === 'function') saveLocal(data.game);
          showToast('Recent players cleared', 'success');
          // Re-render the recent players list on the setup screen if it exists
          if (typeof renderRecent === 'function') {
            renderRecent();
          }
        }
      } catch (e) { showToast('Could not clear recent players', 'error'); }
    });
  </script>

  {% if show_stats %}
  <!-- =========================================================
       SCRIPT: STATS BAR CHART ANIMATION
       ========================================================= -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOMContentLoaded fired for stat bars.');
      const observer = new IntersectionObserver((entries, obs) => {
        entries.forEach(entry => {
          if (entry.isIntersecting) {
            const bar = entry.target;
            const targetWidth = bar.getAttribute('data-width');
            console.log(`Stat bar intersecting: ${bar.outerHTML}, targetWidth: ${targetWidth}`);
            bar.style.setProperty('--target-width', targetWidth || '0px');
            bar.offsetWidth; // Force reflow to ensure initial width:0 is rendered
            bar.classList.add('visible');
            obs.unobserve(bar); // Animate only once
          }
        });
      }, { threshold: 0.1 }); // Trigger when 10% of the bar is visible

      const statBars = document.querySelectorAll('.stat-bar');
      console.log(`Found ${statBars.length} stat bars to observe.`);
      if (statBars.length > 0) {
        statBars.forEach(bar => observer.observe(bar));
      } else {
        console.warn('No .stat-bar elements found. Are they being rendered by Jinja2?');
      }
    });
  </script>
  {% endif %}

  <!-- =========================================================
       SCRIPT: AUTO-HIDE FLASH MESSAGES (RUNS LAST)
       ========================================================= -->
  <script>
    document.addEventListener('DOMContentLoaded', () => {
      const flashMessages = document.querySelectorAll('.flash');
      flashMessages.forEach(flash => {
        setTimeout(() => {
          flash.classList.add('hiding');
          // After the animation, remove the element from the DOM
          flash.addEventListener('transitionend', () => flash.remove(), { once: true });
        }, 3000); // 3 seconds
      });
    });
  </script>
</body>
</html>